## swap 

windows：虚拟内存
linux：swap分区

windows即使物理内存没有用完也会去用到虚拟内存，而Linux不一样 Linux只有当物理内存用完的时候才会去动用虚拟内存（即swap分区）


swap类似于windows的虚拟内存，不同之处在于，Windows可以设置在windows的任何盘符下面，默认是在C盘，可以和系统文件放在一个分区里。而linux则是独立占用一个分区，方便由于内存需求不够的情况下，把一部分内容放在swap分区里，待内存有空余的情况下再继续执行，也称之为交换分区，交换空间是其中的部分。

windows的虚拟内存是电脑自动管理或用户手动设置的
Linux的swap分区是安装系统的时候分好的

### Win10设置虚拟内存

1. 右键点击“我的电脑”，选择“属性”。
2. 在打开的面板中依次打开“高级系统设置”—“高级”选项卡—“设置”—“高级”选项卡—“更改”，就进入了虚拟内存的设置界面。
3. 将“自动管理所有驱动器的分页文件大小”选项前的方框里的勾取消，选择一个盘符（尽量是非系统盘），选择自定义大小，将初始大小和最大值尽量设置为同一数值（可以根据自己电脑的物理内存设置，如电脑物理内存是2GB，就在3GB到6GB之间选择一个数值），然后点击“设置”，最后点击“确定”并重启电脑。



### 虚拟内存（virtual memory）

主存储器可以看成是一个长长的单元格列表，每个单元格都包含一些二进制数据，并标有一个称为内存地址的数字。内存地址的范围从 0 到 N，是根据系统中可用的主存储器的容量而定的。一个程序使用的地址范围称为地址空间。

在计算机历史的初期（现在的嵌入式系统也是如此），程序可以访问整个主内存，且内存的管理交由程序员负责。为这些机器编写软件很有挑战性：开发人员的部分工作是设计出一种好的方法来管理RAM访问，并确保整个程序不会出现内存溢出。

随着多任务处理的出现，事情变得更加棘手，多个程序可以在同一台计算机上同时运行了。程序员们不得不面对新的关键问题：

1. 内存布局 —— 在第一个程序之后加载时RAM中的程序，其地址空间会有一定的偏移，不再是初始范围 0 到 N，在开发过程中多了一个需要注意的痛点。
2. 内存碎片化 —— 当东西来回在内存移动时，可用空间会被分割成越来越小的碎片。这将导致为新的程序和数据找到可用空间更加困难。
3. 安全性 —— 如果程序A不小心覆盖了程序B的内存怎么办？或者更糟糕的：如果它故意从另一个程序中读取敏感数据，比如密码或信用卡信息等敏感数据怎么办？

因此，在20世纪60年代初，硬件架构师们很明显地发现，自动内存管理可以大大简化编程，并解决更关键的内存保护问题。最终，他们设计出了虚拟内存。

在虚拟内存中，程序不能直接访问物理RAM。相反，它与一个称为虚拟地址空间的地址空间进行交互。操作系统与处理器一起工作，提供这种虚拟地址空间，并在需要时将其转换为物理地址空间。

每一次内存访问都是通过一个虚拟地址进行的，而这个虚拟地址并不指向内存中的实际物理位置。程序总是在读取或写入虚拟地址，它完全不知道底层硬件中发生了什么。

##### 虚拟内存的好处

- 每个程序都有一个从0开始的虚拟地址空间 —— 这简化了程序员的工作：无需再手动记录内存偏移量；
- 虚拟内存总是毗连的，即使底层的物理内存不是，操作系统也会把可用的碎片聚集到一个统一的虚拟内存块中。
- 虚拟内存机制还解决了有限RAM的问题：每一个进程都以为自己在未定义数量的内存内工作，前者往往比物理内存更大。
- 虚拟内存还保证了安全性：程序A无法读取或写入分配给程序B的虚拟内存，此类违规行为将触发操作系统错误。

#### Pages(页) 和 frames(桢)：一切的起点

虚拟内存机制需要一个地方来存储虚拟地址和物理地址之间的映射关系。也就是说，给定一个虚拟地址X，系统必须能够找到相应的物理地址Y。然而，你不能把这样的信息以1:1的关系保存下来：不然就需要一个和整个RAM一样大的数据库了！

现代虚拟内存的实现克服了这个问题（以及许多其他问题），它将虚拟内存和物理内存解释为一长串固定大小的小块。虚拟内存的块被称为pages(页)，物理内存的块被称为frames(桢)。内存管理单元（MMU） 是CPU中的一个硬件组件，它将 pages 和 frames 之间的映射信息存储在一个叫做 page table 的特殊数据结构中。page table就像一个数据库表，每一行都包含一个page索引和对应的frame索引。每个运行中的程序在MMU中都有一个 page table。

一个虚拟地址由两个东西组成:

1. 一个page索引，告诉虚拟地址属于哪个page。
2. 一个frame偏移量，告诉物理地址在frame中的位置。

这些信息足以让MMU进行虚拟地址到物理地址的转换。当程序读取或写入一个虚拟地址时，它会唤醒MMU，MMU反过来抓取page索引(1)，并在程序的page table中搜索相应的frame。一旦找到该frame，MMU利用frame的偏移量(2)找到准确的物理内存地址，并将其传回给程序。至此，转换工作完成：程序在RAM中拥有了一个通过虚拟地址进行读写的物理地址。

#### 虚拟内存的背后
虽然程序被提供了一个持续的、干净整洁的虚拟地址空间，但操作系统和硬件仍然有能力在后台用驻留在物理内存中的数据做疯狂的事情。

例如，操作系统经常会延迟从硬盘中加载程序的部分内容，直到程序尝试使用时才继续载入。有些代码只有在初始化期间或发生特殊条件时才会运行。程序的page table中的条目可能会指向不存在或尚未分配的frame，也就是page的映射为空。

像这样的技巧对程序来说是完全透明的，程序会在不知道背景噪音的情况下不停地读写自己的虚拟地址空间。然而，程序迟早会访问到其中一个没有映射到物理RAM的虚拟地址，那时要怎么办？

##### Page faults (缺页错误)
当程序访问没有映射到物理frame上的虚拟地址时，就发生了 page fault（也称为 page miss）。更具体地说，当一个page在程序的page table中存在，但却指向了物理存储器中不存在或尚不可用的frame时，就会发生 page fault。

MMU检测到page fault，并将消息重定向到操作系统，操作系统将尽最大努力在物理内存中找到映射的frame。大多数情况下，这是一个直接的操作，除非系统的RAM用完了。

##### Paging(分页), 或当物理内存不够用时

Paging 是另一种内存管理技巧：当没有更多的物理内存可用时，操作系统会将一些pages移动到硬盘上，为其他程序或数据腾出空间。有时它也被称为swapping，虽然不是100%正确。Swapping(交换)是指将整个进程移动到磁盘上。有些操作系统在需要的时候也会这样做。

分页给程序带来了一种假象，以为可用RAM是无限量的。操作系统乐观地允许虚拟内存地址空间大于物理地址空间，因为它知道数据可以在需要的时候向硬盘中移入移出。有些系统（如Windows）为此目的使用了一个叫做 paging file(分页文件) 的特殊文件。其他系统（如Linux）有一个专门的硬盘分区，称为 swap area(swap区)（由于历史原因，现代Linux执行的是paging，而不是swapping）。

注：paging指的是以页为单位的交换，而swapping指的是以整个进程为单位的交换。

不幸的是，硬盘的速度比主内存要慢得多。所以当出现page fault，临时将page移动到硬盘上时，操作系统必须从低速介质中读取数据，然后将数据移回内存，造成滞后。总而言之，越少的paging意味着系统的运行效率越高。

##### Thrashing(磨蹭?)

当系统在paging中花费的时间多于运行应用程序本身时，就出现了 Thrashing 现象。如果你运行的程序太多，占用了整个内存，或者硬盘上的分页区域没有经过优化时，就会出现这种极端的情况。操作系统会努力跟上大量的page faults请求，不断地在硬盘和物理内存之间移动数据，使系统陷入停顿。可以通过增加RAM、减少正在运行的程序数量或调整swap file的大小，来避免thrashing现象。

##### Memory protection（内存保护）

虚拟内存还提供了运行中的应用程序之间的安全性：你的浏览器不能偷窥到你的文本编辑器的虚拟内存，反之亦然。内存保护的主要目的是防止进程访问不属于它的内存。

内存保护机制通常由MMU和它所管理的page tables提供，而其他架构可能使用不同的硬件策略。当程序试图访问不属于自己的虚拟内存时，就会触发 invalid page fault(无效页故障)。MMU和操作系统会捕捉到这个信号，并发出一个称为segmentation fault(分段故障,在Unix上）或access violation(访问违规,在Windows上）的故障条件。作为响应，操作系统通常会杀死该程序。

Segmentation faults 和 access violations 也常常因疏忽而产生。执行手动内存管理的编程语言允许你预留一部分内存用于存储程序数据：操作系统会给你提供一块不错的空闲内存（又名buffer(缓冲区)），让你根据程序的需要进行读写。但是，没有任何东西可以阻止你在缓冲区边界之外进行读写，访问不属于你的或根本不存在的内存。操作系统会检测到非法访问，并发出通常的违规信号。



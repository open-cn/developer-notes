## Assembly Language

汇编语言


C语言代码 

混合汇编指令

纯汇编指令

机器指令


标记语言、脚本语言、编译语言

强类型语言（静态类型语言）是指需要进行变量/对象类型声明的语言，一般情况下需要编译执行。例如C、C++、Java和C#。

弱类型语言（动态类型语言）是指不需要进行变量/对象类型声明的语言，一般情况下不需要编译(但也有编译型的)。例如PHP、ASP、Ruby、Python、Perl、ABAP、SQL、JavaScript和Unix Shell等。

### 概述

汇编语言是最古老的编程语言，在所有的语言中，它与原生机器语言最为接近。它能直接访问计算机硬件，要求用户了解计算机架构和操作系统。

汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令00000011写成汇编语言就是ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。

最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。

为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。

很自然地，最后还是用文字表达，加法指令写成ADD。内存地址也不再直接引用，而是用标签表示。这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为汇编（assembling），完成这个步骤的程序就叫做汇编器（assembler）。它处理的文本，自然就叫做汇编代码（aseembly code）。标准化以后，称为汇编语言（assembly language，缩写为asm）。




### 语法

#### 数据类型

DB:Define Byte，定义字节(8位/1字节)无符号整数;等同于BYTE;
DW:Define Word，定义字(16位/2字节)无符号整数;等同于WORD;
DD:Define DoubleWord，定义双字(32位/4字节)无符号整数;等同于DWORD;
DF:Defined Farword，定义三字(48位/6字节)无符号整数;等同于FWORD;
DQ:Define QuadWord，定义四字(64位/8字节)无符号整数;等同于QWORD;
DT:Define TenBytes，定义五字(80位/10字节)无符号整数;等同于TBYTE;
BYTE : 8位无符号整数
WORD : 16位无符号整数
DWORD : 32位无符号整数
QWORD : 64位整数
TBYTE : 80位整数
SBYTE : 8位有符号整数
SWORD : 16位有符号整数
SDWORD: 32位有符号整数
FWORD : 48位整数(保护模式下作远指针)
REAL4 : 32位IEEE短实数
REAL8 : 64位IEEE长实数
REAL10: 80位IEEE扩展精度实数

#### 数制

计算机里的内存由数字组成。计算机内存并没有以十进制（基数为10）来储存这些数字。因为计算机以二进制（基数为2）格式来储存所有信息能极大地简化硬件。

##### 十进制
基数为10的数制由10个数码（0-9）组成。一个数的每一位有基于它在数中的位置相关联的10的乘方值。

##### 二进制
基数为2的数制由2个数码（0和1）组成。一个数的每一位有基于它在数中的位置相关联的2的乘方值。

一个二进制数位被称为一个比特位。

##### 十六进制
十六进制数使用的基数为16。通过协定，字母被用来表示这些额外的数字。这16个十六进制数字是0-9，然后A，B，C，D，E和F。数A等价于十进制的10，B是11，等等。一个十六进制的每一位有基于它在数中的位置相关联的16的乘方值。

十六进制（或者简短称为hex）可以用作二进制数的速记形式。

#### 原码/反码/补码

加法器可以做正正相加、负负相加，但是正负相加时？


在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

由于原码在加减运算中的不足引入了补码，为了方便求得补码又引入了反码。

二进制的加法，一个异或门就能实现，多位加法器的实现很容易，然而减法没有找到直接的硬件，但是通过补码能把减法转换成加法来做，这样一种硬件执行结构就可以实现加与减两种基本运算。

对补码的求解过程，其中一个步骤就刚好形成了反码，反码是原码转换成补码的过渡码。


##### 原码

8位二进制码能表示的原码范围是-127~127。有-0，+0。


##### 反码（one's-complement）

8位二进制码能表示的反码范围是-127~127。有-0，+0。

不带符号位取反就是：`127 - |x|`

负数x的反码：`!x = 符号位(-128) + 127 - |x| = -128 + (127 + x)`


##### 补码（two's-complement）

8位二进制码能表示的反码范围是-128~127。有-0 = -128，+0。

有符号二进制整数有正数和负数。

使用的数学原理是：一个整数的补码是其加法逆元。（如果将一个数与其加法逆元相加，结果为 0。）相反数？

负数x的补码：`x = 符号位(-128) + (128 - |x|)= -128 + (128 + x)`即符号位加上正数（128 + x），因此，负数x就可以参与到加法运算中了。减法器诞生了。

1. 补码的设计目的是:
  1) 使符号位能与有效值部分一起参加运算，从而简化运算规则.
  2) 使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计。
  所有这些转换都是在计算机的最底层进行的，而在我们使用的汇编、C等其他高级语言中使用的都是原码。
2. 
	原码：在数值前直接加一符号位的表示法（0正1负）。
	反码：正数的反码同原码；负数的反码是对其原码逐位取反，但符号位除外。
	补码：正数的补码同原码；负数的补码是对其反码+1，但不能影响符号位。
3. 
	1) 二进制数中，两数的补码之和等于两数和的补码。
	2) 目前二进制数进行运算时使用补码，运行结果仍为补码。
	3) 正数的原、反、补码都一样。
	4) 负数的原、反、补码符号位都是1。
	5) 负数时，补码＝反码+1。
	6) 负数时，反码＝原码除符号位外其它数值取反（即该数的绝对值取反），即“0”变“1”，“1”变“0”。
	7) 在计算机中，有符号的数都是采用补码来表示的。
	8) 计算的时候，符号位也参与运算。
	正负相加，次高位进位就是正数，否则是负数。所以减法运算成立。
	对于正正或者负负补码运算，注意数据溢出的问题。
4. 二进制数转换成十进制数
	由二进制数转换成十进制数的基本做法是，把二进制数首先写成加权系数展开式，然后按十进制加法规则求和。这种做法称为"按权相加"法。
5. 十进制数转换为二进制数
	由于整数和小数的转换方法不同，所以先整数和小数分别转换再合并
	十进制整数  "除2取余，逆序排列"
	十进制小数  "乘2取整，顺序排列"

#### 位运算

与& 同或运算 为非运算。

异或^运算，不带进位的加法。
与0异或，为原值。与1...1异或为取反（符号也会变）。异或自身为0。
两个数按位异或意思就是从个位开始，一位一位的比。相同为0，不同为1。
两个数按位同或意思就是从个位开始，一位一位的比。相同为1，不同为0。
与0同或，为取反（符号也会变）。与1...1同或，为原值。同或自身为1...1。


javascript 中所有的按位操作符的操作数都会被转成补码（two's complement）形式的有符号32位整数。
按位与（ AND）	a & b	对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。
按位或（OR）	a | b	对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。
按位异或（XOR）	a ^ b	对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。
按位非（NOT）	~ a	反转操作数的比特位，即0变成1，1变成0。
左移（Left shift）	a << b	将 a 的二进制形式向左移 b (< 32) 比特位，右边用0填充。
有符号右移	a >> b	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 最高位 0或1 在左侧填充。
无符号右移	a >>> b	将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。

java中位数由数据类型来定


#### 内存模型

寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。


程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。

这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。

统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。

如果main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。

等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"后进先出"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。

Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。

##### 栈（Stack）

在操作系统基础中，在一个程序运行的时候，系统会自动给这个程序分配一个栈区。这个栈区和数据结构中所说的栈类似，也支持压栈和弹栈的操作。栈区在逻辑地址空间里是一块连续的空间，栈底是固定的，每次压栈，都会使栈顶向逻辑地址减小的方向移动。


在几个寄存器中，有一个寄存器和栈的关系非常大，那就是rsp寄存器。从它的名字就可以看出来，stack pointer，它存储的值永远是栈顶的地址，所以它又被叫做栈顶指针。

可以用(%rsp)来获取栈顶存储的值，通过a(%rsp)，其中a是任何一个整数，来获取地址是rsp存储的值加a处的内存单元的值。
比如说，2(%rsp)就是栈顶上方（逻辑地址增大方向）2个字节处的值，-2(%rsp)就是栈顶下方（逻辑地址减小方向）2个字节处的值。


压栈和弹栈的助记符分别是push和pop. 这两个操作均有一个操作数。

push的操作是将栈顶指针向下移动（也就是将rsp内的值减小），并将移动后rsp对应位置内存区域的值赋为其操作数，而pop则相反。这里“向下移动”的距离是根据push后面跟着的字母决定的，如pushq就是把rsp内的值减8.

此外，如果是想获得栈顶的值，而不弹栈，可以直接用mov来实现。如popq %rax是将栈顶的8个字节内存储的值赋给rax，并且栈顶指针向上移动8个字节。而movq (%rsp)，%rax则是只将栈顶的8个字节内存储的值赋给rax，不涉及栈顶指针的移动。而如果只想弹栈却不想赋值，那么直接对rsp进行add即可。如想把栈顶的8个字节的数据弹栈，就直接`addq $8, %rsp`。

同时，对于push而言，如果我们一下子准备把许多值压入栈内，那么可以先用sub指令减小rsp，再用mov移动。


使用局部变量

通过对rsp中存储的地址加偏移量去访问局部变量

寄存器rbp，顾名思义，base pointer，基地址指针，一般是用来使用偏移量寻址的。

寻址方式：`$偏移量(%基址, %指标, $倍数)`。这个记号代表地址为`基址+指标*倍数+偏移量`处的内存单元中存储的值。

其中，以$开头的都是数字（但注意我们真正写的时候不需要加上$符号），以%开头的都是寄存器。也就是说，在偏移量、倍数的位置上，不能写寄存器，在基址、指标的位置上，不能写数字。此外，倍数只能是1，2，4，8中的一个。



##### 堆栈帧（stack frame）
堆栈帧（或活动记录，activation Tecord）是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器。

堆栈帧的创建步骤如下所示：

1) 被传递的实际参数。如果有，则压入堆栈。
2) 当子程序被调用时，使该子程序的返回值压入堆栈。
3) 子程序开始执行时，EEP 被压入堆栈。
4) 设置 EBP 等于 ESP。从这时开始，EBP 就变成了该子程序所有参数的引用基址。
5) 如果有局部变量，修改 ESP 以便在堆栈中为这些变量预留空间。
6) 如果需要保存寄存器，就将它们压入堆栈。

#### 存储管理

两个主要方面：
- 将逻辑地址转换为线性地址
- 将线性地址转换为物理地址（分页）

x86 存储管理术语：
- 多任务处理 (multitasking) 允许多个程序（或任务）同时运行。处理器在所有运行程序中划分其时间。
- 段 (segments) 是可变大小的内存区，用于让程序存放代码或数据。
- 分段 (segmentation) 提供了分隔内存段的方法。它允许多个程序同时运行又不会相互干扰。
- 段描述符 (segment descriptor) 是一个 64 位的值，用于标识和描述一个内存段。它包含的信息有段基址、访问权限、段限长、类型和用法。
- 段选择符 (segment selector) 是保存在段寄存器 (CS、DS、SS、ES、FS 或 GS) 中的一个 16 位数值。
- 逻辑地址 (logical address) 就是段选择符加上一个 32 位的偏移量。


##### 逻辑地址转换为线性地址


分页



描述符表




段描述符详细信息

1) 基址
2) 特权级
3) 段类型
4) 段存在标志
5) 粒度标志
6) 段限长

##### 线性地址转换位物理地址

### 调试和汇编


#### 调试

载入程序
lldb test

(lldb) run

./test helloworld 114514
(lldb) run helloworld 114514


设置断点
(lldb) breakpoint set --file test.s --line 6

(lldb) run
(lldb) continue
(lldb) nexti




寄存器与内存
(lldb) register read

(lldb) register read rsp

(lldb) memory read 0x00007ffeefbff7b8


编译
clang test.c -S -o test.s


汇编
as test.s -o test.o

链接
ld test.o tmp.o -o test -lSystem



动态链接

otool -L test







### 示例

gcc 将c程序转成汇编语言。
```c
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
```
```shell
gcc -S example.c
```
```
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
```

程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。

开始执行第一行代码。

`push   3`
push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。
先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。

`push   2`

`call   _add_a_and_b`
调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。

下面就开始执行_add_a_and_b的代码。

`push   %ebx`
将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。

`mov    %eax, [%esp+8]`
将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，这里取出的是2，再将2写入 EAX 寄存器。【不是ESP 寄存器了】

`mov    %ebx, [%esp+12]`
这里取出的是3，再将3写入 EBX 寄存器。【不是ESP 寄存器，也不是EAX 寄存器】

`add    %eax, %ebx`
将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。

`pop    %ebx`
pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。
注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。

`ret`
ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。

`add    %esp, 8`
将 ESP 寄存器里面的地址，手动加上8个字节。前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。
编译器规定函数调用，由调用者恢复栈平衡，所以最后是main函数部分做加8这个操作。

`ret`
main函数运行结束，ret指令退出程序执行。











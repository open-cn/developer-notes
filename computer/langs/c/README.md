## C

### 概述

C语言的三套标准：C89、C99和C11


### 语法
C语言程序的错误和警告

错误（Error）表示程序不正确，不能正常编译、链接或运行，必须要纠正。

警告（Warning）表示可能会发生错误（实际上未发生）或者代码不规范，但是程序能够正常运行，有的警告可以忽略，有的要引起注意。

#### 函数（Function）

自定义函数和main函数

形参和实参的区别

函数返回值

函数声明（Declaration）以及函数原型

#### 变量

全局变量（Global Variable）和局部变量（Local Variable）

作用域（Scope），就是变量的有效范围。

静态作用域(static scope)，也称为词法作用域(lexical scope)
动态作用域(dynamic scope)

#### 其它
块结构(block structure)

值传递(call-by-value)
引用传递(call-by-reference) 


头文件的概念



- 空格、制表符、换行符等统称为空白符（space character），它们只用来占位，并没有实际的内容，也显示不出具体的字符。
- 制表符分为水平制表符和垂直制表符，它们的 ASCII 编码值分别是 9 和 11。
- 垂直制表符在现代计算机中基本不再使用了，也没法在键盘上直接输入，它已经被换行符取代了。
- 水平制表符相当于四个空格，对于大部分编辑器，按下 Tab 键默认就是输入一个水平制表符；如果你进行了个性化设置，按下 Tab 键也可能会输入四个或者两个空格。

转义字符

关键字（Keywords）是由C语言规定的具有特定意义的字符串，通常也称为保留字，例如 int、char、long、float、unsigned 等。

变量和数据类型

数组

运算符的优先级和结合性

数据类型转换（自动类型转换+强制类型转换）

自增(++)和自减(--)
- ++ 在前面叫做前自增（例如 ++a）。前自增先进行自增运算，再进行其他操作。
- ++ 在后面叫做后自增（例如 a++）。后自增先进行其他操作，再进行自增运算。

循环结构和选择结构

关键字 typedef 可以为类型起一个新的别名。typedef 的用法一般为：
typedef  oldName  newName;

指针

结构体



输入输出（Input and Output，IO）
输入输出是用户和程序“交流”的过程。在控制台程序中，输出一般是指将数据（包括数字、字符等）显示在屏幕上，输入一般是指获取用户在键盘上输入的数据。

在C语言中，有三个函数可以用来在显示器上输出数据，它们分别是：
- puts()：只能输出字符串，并且输出结束后会自动换行。
- putchar()：只能输出单个字符。
- printf()：可以输出各种类型的数据。

printf() 的高级用法

printf() 不能立即输出的问题

从本质上讲，printf()执行结束以后数据并没有直接输出到显示器上，而是放入了缓冲区，直到遇见换行符`\n`才将缓冲区中的数据输出到显示器上。


scanf()函数

读取从键盘输入的数据（含输入格式汇总表）


文件操作

在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。例如：
- 通常把显示器称为标准输出文件，printf 就是向这个文件输出数据；
- 通常把键盘称为标准输入文件，scanf 就是从这个文件读取数据。

常见硬件设备所对应的文件

文件|硬件设备
---|---
stdin|标准输入文件，一般指键盘；scanf()、getchar() 等函数默认从 stdin 获取输入。
stdout|标准输出文件，一般指显示器；printf()、putchar() 等函数默认向 stdout 输出数据。
stderr|标准错误文件，一般指显示器；perror() 等函数默认向 stderr 输出数据（后续会讲到）。
stdprn|标准打印文件，一般指打印机。



所有的文件（保存在磁盘）都要载入内存才能处理，所有的数据必须写入文件（磁盘）才不会丢失。数据在文件和内存之间传递的过程叫做文件流，类似水从一个地方流动到另一个地方。数据从文件复制到内存的过程叫做输入流，从内存保存到文件的过程叫做输出流。

文件是数据源的一种，除了文件，还有数据库、网络、键盘等；数据传递到内存也就是保存到C语言的变量（例如整数、字符串、数组、缓冲区等）。我们把数据在数据源和程序（内存）之间传递的过程叫做数据流(Data Stream)。相应的，数据从数据源到程序（内存）的过程叫做输入流(Input Stream)，从程序（内存）到数据源的过程叫做输出流(Output Stream)。

输入输出（Input output，IO）是指程序（内存）与外部设备（键盘、显示器、磁盘、其他计算机等）进行交互的操作。几乎所有的程序都有输入与输出操作，如从键盘上读取数据，从本地或网络上的文件读取数据或写入数据等。通过输入和输出操作可以从外界接收信息，或者是把信息传递给外界。

打开文件就是打开了一个流。

fopen() 函数







#### 预处理命令

宏定义和条件编译

在编译之前对源文件进行简单加工的过程，就称为预处理（即预先处理、提前处理）。预处理是C语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。

以#号开头的命令称为预处理命令。

- #define 叫做宏定义命令
- #if、##ifdef、#ifndef 条件编译
- #error命令，阻止程序编译

指令|说明
---|---
#|空指令，无任何效果
#include|包含一个源代码文件
#define|定义宏
#undef|取消已定义的宏
#if|如果给定条件为真，则编译下面代码
#ifdef|如果宏已经定义，则编译下面代码
#ifndef|如果宏没有定义，则编译下面代码
#elif|如果前面的#if给定条件不为真，当前条件为真，则编译下面代码
#endif|结束一个#if……#else条件编译块



头文件的编写（多文件编程）

### 错误处理

错误处理是程序设计时必须要考虑的问题。

错误分两种，一种是程序写的逻辑不对，导致代码执行异常。对于这种错误，要修复程序。

另一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。
对于这种错误，我们需要处理它，并可能需要给用户反馈。


对于C这样贴近系统底层的语言，错误是通过错误码返回的：

int fd = open("/path/to/file", O_RDONLY);
if (fd == -1) {
    printf("Error when open file!");
} else {
    // TODO
}

上面的open()函数约定返回-1表示错误。


显然，这种用错误码表示错误在编写程序时十分不便。因此，高级语言通常都提供了更抽象的错误处理逻辑`try ... catch ... finally`。










### 可移植的（portable）

一种语言，如果它的源程序能够在各种各样的计算机系统中进行编译和运行，那么这种语言被称为是可移植的（portable）。

例如，
一个 C++ 程序，除非需要特别引用某种操作系统的库函数，否则它就几乎可以在任何一台计算机上编译和运行。
Java 语言的一大特点就是，其编译好的程序几乎能在所有计算机系统中运行。



汇编语言不是可移植的，因为它是为特定处理器系列设计的。目前广泛使用的有多种不同的汇编语言，每一种都基于一个处理器系列。

对于一些广为人知的处理器系列如 Motorola 68x00、x86、SUN Sparc、Vax 和 IBM-370，汇编语言指令会直接与该计算机体系结构相匹配，或者在执行时用一种被称为微代码解释器（microcode interpreter）的处理器内置程序来进行转换。




下表比较了汇编语言和高级语言对各种应用类型的适应性。

应用类型|高级语言|汇编语言
---|---|---
商业或科学应用程序，为单一的中型或大型平台编写|规范结构使其易于组织和维护大量代码|最小规范结构，因此必须由具有不同程度经验的程序员来维护结构。这导致对已有代码的维护困难
硬件设备驱动程序|语言不一定提供对硬件的直接访问。 即使提供了，可能也需要难以控制的编码技术，这导致维护困难|对硬件的访问直接且简单。当程序较短且文档良好时易于维护
为多个平台（不同的操作系统）编写的商业或科学应用程序|通常可移植。在每个目标操作系统上， 源程序只做少量修改就能重新编译|需要为每个平台单独重新编写代码， 每个汇编器都使用不同的语法。维护困难
需要直接访问硬件的嵌入式系统和电脑游戏|可能生成很大的可执行文件，以至于超出设备的内存容量|理想，因为可执行代码小，运行速度快

C 和 C++ 语言具有一个独特的特性，能够在高级结构和底层细节之间进行平衡。直接访问硬件是可能的，但是完全不可移植。大多数 C 和 C++ 编译器都允许在其代码中嵌入汇编语句，以提供对硬件细节的访问。

### 工程类型/项目类型

“程序”是一个比较宽泛的称呼，它可以细分为很多种类，例如：
有的程序不带界面，完全是“黑屏”的，只能输入一些字符或者命令，称为控制台程序（Console Application），例如 Windows 下的 cmd.exe，Linux 或 Mac OS 下的终端（Terminal）。
有的程序带界面，看起来很漂亮，能够使用鼠标点击，称为GUI程序（Graphical User Interface Program），例如 QQ、迅雷、Chrome 等。
有的程序不单独出现，而是作为其它程序的一个组成部分，普通用户很难接触到它们，例如静态库、动态库等。



### 数据在内存中的存储（二进制形式存储）


内存条是一个非常精密的部件，包含了上亿个电子元器件，它们很小，达到了纳米级别。这些元器件，实际上就是电路；电路的电压会变化，要么是 0V，要么是 5V，只有这两种电压。5V 是通电，用1来表示，0V 是断电，用0来表示。所以，一个元器件有2种状态，0 或者 1。


单位换算：
- 1Byte = 8 Bit
- 1KB = 1024Byte = 210Byte
- 1MB = 1024KB = 220Byte
- 1GB = 1024MB = 230Byte
- 1TB = 1024GB = 240Byte
- 1PB = 1024TB = 250Byte
- 1EB = 1024PB = 260Byte




### 载入内存（Load into Memory）




### 同步 I/O

阻塞 I/O 是 read / write 函数的默认执行机制，会在读写操作执行时将进程置为阻塞态，I/O 完成后，由系统中断将其置为就绪态，等待时间片分配，并执行。


但阻塞 I/O 的机制存在一个问题，就是无法并发地执行 I/O 操作，或者在 I/O 操作执行的同时执行 CPU 的计算。

第一个思路是使用多线程。

我们预先初始化一个线程池，利用信号量的 wait 原语进入阻塞状态。等到有 I/O 操作需求时，通过信号量signal将线程唤醒并执行相关的 I/O 操作。
但多线程非阻塞 I/O 有个弊端，就是当连接数达到很大的一个程度时，线程切换也是一笔不小的开销。
所以，期望能够在一个线程内解决 I/O 的等待操作，避免开启多个线程而造成的线程上下文切换的开销。有没有这样的方式呢，所以就可以引入非阻塞 I/O 的模式了。

非阻塞 I/O 是一种机制，允许用户在调用 I/O 读写函数后，立即返回，如果缓冲区不可读或不可写，直接返回 -1。

非阻塞 I/O 能够帮我们解决在一个线程并发执行 I/O 操作的需求，可同样会带来问题：
如果 while 循环轮询等待执行的操作，会造成不必要的 CPU 运算的浪费，因为此时 I/O 操作未完成，read 函数拿不到结果；
如果使用 sleep/usleep 的方式强行让进程睡眠一段时间，又回造成 I/O 操作的返回不及时。
所以，系统有没有一种机制来允许我们原生地等待多个 I/O 操作的执行呢。答案是有的，需要引入我们的 I/O 多路复用。

I/O 多路复用，故名意思是在一个进程内同时执行多个 I/O 操作。本身也有一段进化的过程，分别是 select, poll, epoll（macos 上的替代品是 kqueue） 这几个阶段。

### 异步 I/O

同步 I/O。都需要用户等待 I/O操作完成，并接收返回的内容。而操作系统本身也提供了异步 I/O 的方案，对应到不同的操作系统：

Linux
    aio，目前比较被诟病，比较大缺陷是只支持 Direct I/O（文件操作）
    io_uring， Linux Kernel 在 5.1 版本加入的新东西，被认为是 Linux 异步 I/O 的新归宿
windows
    iocp，作为 libuv 在 windows 之上的异步处理方案。


### libuv I/O 模型

libuv 使用 epoll 来构建 event-loop 的主体，其中：
socket, pipe 等能通过 epoll 方式监听的 fd 类型，通过 epoll_wait 的方式进行监听；
文件处理 / DNS 解析 / 解压、压缩等操作，使用工作线程的进行处理，将请求和结果通过两个队列建立联系，由一个 pipe 与主线程进行通信， epoll 监听该 fd 的方式来确定读取队列的时机。















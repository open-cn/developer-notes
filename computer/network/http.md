## 超文本传输协议

HyperText Transfer Protocol，HTTP

### 概述

欧洲核子研究组织的 Tim Berners-Lee 博士提出了一种能够让远隔两地的网民共享知识的设想，最初的理念是：借助多文档之间相互关联的超文本（HyperTest），连成可相互参阅的 WWW（World Wide Web，万维网）。

现在已提出了 3 项 WWW 构建技术，分别是：
- 把 SGML（标准通用标记语言）作为页面的文本标记语言 HTML
- 作为文档传递协议的 HTTP
- 指定文档所在地址的 URL

WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序的名称，现在用来表示这一系列的集合，也可简称为 Web。

HTTP/0.9：HTTP 于 1990 年问世，功能简陋，仅支持 GET 请求方式，并且仅能访问 HTML 格式的资源。那时的 HTTP 并没有作为正式的标准被建立，因此被被称为 HTTP 0.9。

HTTP/1.0：1996 年 5 月 HTTP 正式作为标准被公布，版本号为 HTTP 1.0。
在 0.9 版本上做了进步，增加了请求方式 POST 和 HEAD；不再局限于 0.9 版本的 HTML 格式，根据 Content-Type 可以支持多种数据格式。
需要注意的是：1.0 版本的工作方式是短连接。
虽说 HTTP/1.0 是初期标准，但该协议标准至今仍然在被广泛使用。

HTTP/1.1：1997 年公布的 HTTP 1.1 是目前主流的 HTTP 协议版本。当年的 HTTP 协议的出现主要是为了解决文本传输的难题，现在的 HTTP 早已超出了 Web 这个框架的局限，被运用到了各种场景里。当然，1.1 版本的最大变化，就是引入了长连接以及流水线机制（管道机制）。


### HTTP 请求方法

HTTP 1.1：GET、POST、PUT、HEAD、DELETE、OPTIONS、CONNECT、TRACE

GET 获取资源

POST 传输实体主体

PUT 传输文件

PUT 方法用来传输文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

HEAD 获取报文首部

DELETE 删除文件

同样不带验证机制

OPTIONS 查询支持的方法

用于获取当前 URI 所支持的方法。若请求成功，会在 HTTP 响应头中包含一个名为 “Allow” 的字段，值是所支持的方法，如 “GET, POST”。


#### HTTP请求报文

HTTP 请求头

Referer：表示这个请求是从哪个 URI 跳过来的

这个字段通常用于防盗链

Accept：告诉服务端，该请求所能支持的响应数据类型
（对应的，HTTP 响应报文中也有这样一个类似的字段Content-Type，用于表示服务端发送的数据类型，如果Accept指定的类型和服务端返回的类型不一致，就会报错）


Host：告知服务器请求的资源所处的互联网主机名和端口号。

该字段是 HTTP/1.1 规范中唯一一个必须被 包含在请求头中的字段。


Cookie

Connection：表示客户端与服务连接类型；Keep-Alive 表示持久连接，close 已关闭

Content-Length：请求体的长度

Accept-Language」：浏览器通知服务器，浏览器支持的语言

Range」：对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围



#### HTTP响应报文


HTTP 状态码负责表示客户端 HTTP 请求的的返回结果、标记服务器端处理是否正常、通知出现的错误等工作

类别|原因短语|
---|---|---
1xx|Informational 信息性状态码|接收的请求正在处理
2xx|Success 成功状态码|请求正常处理完毕
3xx|Redirection 重定向状态码|需要进行附加操作以完成请求
4xx|Client Error 客户端错误状态码|服务器无法处理请求
5xx|Server Error 服务器错误状态码|服务器处理请求出错

HTTP 响应头


### HTTP 连接管理


短连接（非持久连接）

在 HTTP 协议的初始版本（「HTTP/1.0」）中，「客户端和服务器每进行一次 HTTP 会话，就建立一次连接，任务结束就中断连接」。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如JavaScript 文件、图像文件、CSS文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。这种方式称为「短连接」（也称「非持久连接」）。

每次 HTTP 请求都要重新建立一次连接。由于 HTTP 是基于 TCP/IP 协议的，所以连接的每一次建立或者断开都需要 TCP 三次握手或者 TCP 四次挥手的开销。



长连接（持久连接）

从「HTTP/1.1」起，默认使用「长连接」也称「持久连接 keep-alive」。使用长连接的 HTTP 协议，会在响应头加入这行代码：Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。「Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间」。实现长连接需要客户端和服务端都支持长连接。


HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

流水线（管线化）


默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。
持久连接使得多数请求以「流水线」（管线化 pipeline）方式发送成为可能，即在「同一条持久连接上连续发出请求，而不用等待响应返回后再发送」，这样就可以做到同时「并行」发送多个请求，而不需要一个接一个地等待响应了。





无状态的 HTTP


HTTP 协议是无状态协议。也就是说他不对之前发生过的请求和响应的状态进行管理，即无法根据之前的状态进行本次的请求处理。

这样就会带来一个明显的问题，如果 HTTP 无法记住用户登录的状态，那岂不是每次页面的跳转都会导致用户需要再次重新登录？
当然，不可否认，无状态的优点也很显著，由于不必保存状态，自然就减少了服务器的 CPU 及内存资源的消耗。另一方面，正式由于 HTTP 简单，所以才会被如此广泛应用。

这样，在保留无状态协议这个特征的同时，又要解决无状态导致的问题。方案有很多种，其中比较简单的方式就是使用「Cookie」技术。


HTTP 断点续传

原理就是 HTTP 请求头中的字段Range和响应头中的字段Content-Range的简单使用。



HTTP 的缺点：
- 通信使用明文（不加密），内容可能被「窃听」
- 不验证通信对方的身份，因此有可能遭遇「伪装」
- 无法证明报文的完整性，所以有可能被「篡改」


HTTPS 协议 = HTTP + 加密 + 认证 + 完整性保护  

## Central Processing Unit

中央处理器，CPU

处理器包括一组寄存器，提供一定的存储能力。有两个功能：
1、用户可见寄存器；
可以被应用程序、系统程序使用。

数据寄存器
地址寄存器
索引寄存器
段指针
栈指针

2、控制和状态寄存器。

程序计数器
指令寄存器
条件码


指令的执行
处理器-存储器
处理器-i/o
数据处理
控制



主存储器
输入/输出模块
系统总线







进程 多线程 对称多处理smp 微内核


单一系统 并发机制 互斥和死锁

存储器管理技术 虚拟存储器

进程调度 线程调度 smp调度 实时调度


输入、输出和文件管理


分布式系统和安全


windows 多任务操作系统 个人计算机 工作站和服务器



unix 多用户操作系统 微机到超级计算机





### 概述

中央处理器（CPU）是执行指令的物理设备。CPU执行的指令通常非常简单。指令可能要求他们使用的数据存储在一个称为寄存器的特殊储存位置中。CPU可以比访问内存更快地访问寄存器里的数据。然而，在CPU里的寄存器是有限的，所以程序员必须注意只保存现在使用的数据到寄存器中。

各类CPU执行的指令组成了该CPU的机器语言。机器语言拥有比高级语言更基本的结构。机器语言指令被编码成未加工的数字，而不是友好的文本格式。为了更有效的运行，CPU必须能很快地解释一个指令的目的。机器语言就是为了这个目的设计的，而不是让人们更容易理解而设计。一个其他语言写的程序必须转换成CPU的本地机器语言，才能在电脑上运行。

编译器是一个将用用程序语言写的程序翻译成特殊结构的电脑的机器语言的程序。通常，每一种类型的CPU都有它自己唯一的机器语言。这是为什么为Mac写的程序不能在IBM类型PC机运行的一个原因。

电脑通过使用时钟来同步指令的执行。时钟脉冲在一个固定的频率（称为时钟频率）。当你买了一台1.5GHz的电脑，1.5GHz就是时钟频率。时钟并不记录分和秒。它以不变的速率简单跳动。电子计算机通过使用这个跳动来正确执行它们的操作，就像节拍器的跳动如何来帮助你以正确的节奏播放音乐。一个指令需要跳动的次数（或就像他们经常说的执行周期）依赖CPU的产生和模仿。周期的次数取决于它之前的指令和其他因素。


#### CPU 80x86系列

IBM型号的PC机包含了一个来自Intel 80x86家族（或它的克隆）的CPU。在这个家族的所有CPU都有一些普遍的特征，包括有一种基本的机器语言。

8088，8086: 这些CPU从编程的观点来看是完全相同的。它们是用在早期PC机上的CPU。它们提供一些16位的寄存器：AX，BX，CX，DX，SI，DI，BP，SP，CS，DS，SS，ES，IP，FLAGS。它们仅仅支持1M字节的内存，而且只能工作在实模式下。在这种模式下，一个程序可以访问任何内存地址，甚至其它程序的内存！这会使排除故障和保证安全变得非常困难！而且，程序的内存需要分成段。每段不能大于64K。

80286: 这种CPU使用在AT系列的PC机中。它在8088/86的基本机器语言中加入了一些新的指令。然而，它主要的新的特征是16位保护模式。在这种模式下，它可以访问16M字节的内存和通过阻止访问其它程序的内存来保护程序。可是，程序依然是分成不能大于64K的段。

80386: 这种CPU极大地增强了80286的性能。首先，它扩展了许多寄存器来容纳32位数据（EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP，EIP）而且增加了两个新的16位寄存器（FS，GS）。它同样增加了一个新的32位保护模式。在这种模式下，它可以访问4G字节。程序同样分成段，但是现在每段大小同样可以到4G。

80486/Pentium/Pentium Pro: 这些80x86家族的成员增加了不多的新的特征。它们主要是提高了指令执行的速度。

Pentium MMX: 这些处理器在Pentium基础上增加了MMX指令（多媒体扩展）。这些指令可以提高普通的图像操作的速率。

Pentium II: 它是拥有MMX 指令的Pentium处理器。（Pentium III 本质上就是一个更快的Pentium II。）

##### 8086 16位寄存器

最初的8086CPU提供4个16位通用寄存器：AX，BX，CX和DX。这些寄存器都可以分解成两个8位寄存器。例如：AX寄存器可以分解成AH和AL寄存器。AH寄存器包含AX的上（或高）8位，而AL包含AX的低8位。通常AH和AL都当做独立的一个字节的寄存器来用；但是，清楚它们不能独立于AX是非常重要的。改变AX的值将会改变AH和AL的值，反之亦然。通用寄存器多数使用在数据移动和算术指令中。

还有两个16位指针寄存器：SI和DI。通常它们都是当作指针来使用，但是在许多情况下也可以像通用寄存器一样使用。但是，它们不可以分解成8位寄存器。

16位BP和SP寄存器用来指向机器语言堆栈里的数据，被各自称为基址寄存器和堆栈指针寄存器。

16位CS，DS，SS和ES寄存器是段寄存器。它们指出程序不同部分所使用的内存。CS代表代码段，DS代表数据段，SS代表堆栈段和ES代表附加段。ES当作一个暂时段寄存器来使用。

指令指针寄存器（IP）与CS寄存器一起使用来跟踪CPU下一条执行指令的地址。通常，当一条指令执行时，IP提前指向内存里的下一条指令。

FLAGS寄存器储存了前面指令执行结果的重要信息。这些结果在寄存器里以单个的位储存。例如：如果前面指令执行结果是0，Z位为1，反之为0。并不是所有指令都修改FLAGS里的位，查看附录里的表看单个指令是如何影响FLAGS寄存器的。

##### 80386 32位寄存器

80386及以后的处理器扩展了寄存器。例如：16位AX寄存器扩展成了32位。为了向后兼容，AX依然表示16位寄存器，而EAX用来表示扩展的32位寄存器。AX是EAX的低16位就像AL是AX（EAX）的低8位一样。但是没有直接访问EAX高16位的方法。其它的扩展寄存器是EBX，ECX，EDX，ESI和EDI。

许多其它类型的寄存器同样也扩展了。BP变成了EBP；SP变成了ESP；FLAGS变成了EFLAG、SEFLAGS；而IP变成了EIP。但是，不同于指针寄存器和通用寄存器，在32位保护模式下，只有这些寄存器的扩展形式被使用。

在80386里，段寄存器依然是16位的。有两个新的段寄存器：FS和GS。它们名字并不代表什么。它们是附加段寄存器（像ES一样）。术语中“字”的一个定义为CPU数据寄存器的大小。对于80x86家族，这个术语现在有一点混乱了。当8086第一次发行时它被定义成两个字节。当80386开发出来后，它被决定依旧保持这个“字”定义不改变，即使寄存器的大小已经改变了。


### 工作模式

#### 实模式

在实模式下，内存被限制为仅有1M字节（2^20字节）。有效的地址从00000到FFFFF（十六进制）。这些地址需要用20位的数来表示。显然，一个20位的数不适合任何一个8086的16位寄存器。Intel通过利用两个16位数值来决定一个地址的方法来解决这个问题。开始的16位值称为段地址（selector）。段地址的值存储在段寄存器中。第二个16位值称为偏移地址（offset）。偏移地址表示的物理地址可以由公式计算：`16 * selector + offset`。

实际上，段地址的值是一节的首地址。真实的段地址有以下的缺点：

1. 一个段地址只能指向64K内存（16位偏移的上限）。如果一个程序拥有大于64K的代码那又怎么办呢？在CS里的一个单一的值不能满足整个程序执行的需要。程序必须分成小于64K的段（segment）。当执行从一段移到另一段时，CS里的值必须改变。同样的问题发生在大量的数据和DS寄存器之间。这样使用是非常不方便的！
2. 每个字节在内存里并不只有唯一的段地址。物理地址04808可以表示为：047C:0048，047D:0038，047E:0028或047B:0058。这将使段地址的比较变得复杂。

#### 16位保护模式

在80286的16位保护模式下，段地址的值与实模式相比解释得完全不同。在实模式下，一个段地址的值是物理内存里的一节的首地址。在保护模式下，一个段地址的值是一个指向描述符表的指针。两种模式下，程序都是被分成段。在实模式下，这些段在物理内存的固定位置而且段地址的值表示段开始处所在节的首地址。在保护模式下，这些段不是在物理内存的固定的地址。事实上，它们根本不一定需要在内存中。

保护模式使用了一种叫做虚拟内存的技术。虚拟内存的基本思想是仅仅保存程序现在正在使用的代码和数据到内存中。其它数据和代码暂时储存在硬盘中直到它们再次需要时。当一段从硬盘重新回到内存中，它很有可能放在不同于它移动到硬盘之前时的位置的内存中。所有这些都由操作系统透明地执行。程序并不需要因为要让虚拟内存工作而使用不同的书写方法。

在保护模式下，每一段都分配了一条描述符表里的条目。这个条目拥有系统想知道的关于这段的所有信息。这些信息包括：现在是否在内存中；如果在内存中，在哪；访问权限(例如： 只读)。段的条目的指针是储存在段寄存器里的段地址值。

16位保护模式的一个大的缺点是偏移地址依然是16位数。这个的后果就是段的大小依然限制为最大64K。这会导致使用大的数组时会有问题。

#### 32位保护模式

80386引入了32位保护模式。386 32位保护模式和286 16位保护模式之间最主要的区别是：
1. 偏移地址扩展成了32位。这就允许偏移地址范围升至4G。因此，段的大小也升至4G。
2. 段可以分成较小的4K大小的单元，称为内存页。虚拟内存系统工作在页的方式下，代替了段方式。这就意味着一段在任何一个时刻只有部分可能在内存中。在28616位保护模式下，要么整个段在内存中，要么整个不在。这样在32位模式下允许的大的段的情况下很不实用。

在Windows 3.x系统中，标准模式为286 16位保护模式而增强模式为32位保护模式。Windows 9X，Windows NT/2000/XP，OS/2和Linux都运行在分页管理的32位保护模式下。

#### 中断

有时候普通的程序流必须可以被要求快速反应的处理事件中断。电脑提供了一个称为中断的结构来处理这些事件。例如：当一个鼠标移动了，硬件鼠标中断现在的程序来处理鼠标移动(移动鼠标，等等)。中断导致控制权转移到一个中断处理程序。中断处理程序是处理中断的程序。每种类型的中断都分配了一个中断号。在物理内存的开始处，存在一张包含中断处理程序段地址的中断向量表。中断号是这张表中最基本的指针。

外部中断由CPU的外部引起。(鼠标就是这一类型的例子。)许多I/O设备引起中断(例如：键盘，时钟，硬盘驱动器，CD-ROM和声卡)。内部中断由CPU的内部引起，要么是由一个错误引起，要么由中断指令引起。错误中断称为陷阱。由中断指令引起的中断称为软中断。DOS使用这些类型的中断来实现它的API(应用程序接口)。许多现代的操作系统(如：Windows和UNIX)使用一个基于C的接口。

许多中断处理程序当它执行完成时，将控制权返回给被中断的程序。它们恢复寄存器，里面的值与中断发生之前的值相同。因此，被中断的程序就像没有任何事情发生一样运行(除了它失去了一些CPU周期)。陷阱通常不返回。通常它们中止程序。




















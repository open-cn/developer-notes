## Math

### 超集和子集
定义：如果一个集合S2中的每一个元素都在集合S1中，且集合S1中可能包含S2中没有的元素，则集合S1就是S2的一个超集，反过来，S2是S1的子集。  
S1是S2的超集，若S1中一定有S2中没有的元素，则S1是S2的真超集，反过来S2是S1的真子集。



### 环比和同比

环比和同比是描述数据变动的方法

「环比」与「上一个」统计周期比较，例如2011年4月份与2011年3月份相比较，称为「环比」。

「同比」与历史「同时期］比较，例如2011年3月份与2010年3月份相比，叫「同比」。

同比和环比侧重点不同，环比会突出显示数据的短期趋势，会受到季节等因素的影响。而同比更加侧重反映长期的大趋势，也就规避了季节的因素。在分析数据时要灵活运用同比和环比，以突出我们想要表现的数据。


### 数据结构
数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系。

逻辑结构包括：

1. 集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；
2. 线性结构：数据结构中的元素存在一对一的相互关系；
3. 树形结构：数据结构中的元素存在一对多的相互关系；
4. 图形结构：数据结构中的元素存在多对多的相互关系。

#### 数组(Array)
数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。
#### 栈( Stack)
栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。
#### 队列(Queue)
队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。
#### 链表(Linked List)
链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。
#### 树(Tree)
树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。
#### 图(Graph)
图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。
#### 堆(Heap)
堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。 
#### 散列表(Hash)
散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

### 树

树是一种非线性的数据结构，它是由n（n>=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下。

在树形结构中，树根结点没有前驱结点，其余每个结点有且只有一个前驱结点。叶子结点没有后续结点，其余每个结点的后续节点数可以是一个也可以是多个。

树是递归定义的。

- 树形结构中，子树之间不能有交集，否则就不是树形结构。
- 除了根节点外，每个节点有且只有一个父节点。
- 一棵树N个节点的树有N-1条边。

#### 名词概念

- 结点(Node)：表示树中的数据元素，由数据项和数据元素之间的关系组成。
- 结点的度(Degree of Node)：结点所拥有的子树的个数。
- 树的度(Degree of Tree)：树中各结点度的最大值。
- 叶子结点(Leaf Node)：度为0的结点，也叫终端结点。
- 分支结点(Branch Node)：度不为0的结点，也叫非终端结点或内部结点。
- 结点的层次(Level of Node)：从根结点到树中某结点所经路径上的分支数称为该结点的层次。根结点的层次规定为1，其余结点的层次等于其双亲结点的层次加1。 
- 树的深度(Depth of Tree)：也称为树的高度，树中所有节点的层次最大值。

- 孩子(Child)：结点子树的根。
- 双亲(Parent)：结点的上层结点叫该结点的双亲。
- 祖先(Ancestor)：从根到该结点所经分支上的所有结点。
- 子孙(Descendant)：以某结点为根的子树中的任一结点。
- 兄弟(Brother)：同一双亲的孩子。
- 堂兄弟(Sibling)：同一层的双亲不同的结点。

- 无序树(Unordered Tree)：树中任意一个结点的各孩子结点之间的次序构成无关紧要的树。通常树指无序树。
- 有序树(Ordered Tree)：树中任意一个结点的各孩子结点有严格排列次序的树。二叉树是有序树，因为二叉树中每个孩子结点都确切定义为是该结点的左孩子结点还是右孩子结点。
- 森林(Forest)：m(m≥0)棵树的集合。自然界中的树和森林的概念差别很大，但在数据结构中树和森林的概念差别很小。从定义可知，一棵树由根结点和m个子树构成，若把树的根结点删除，则树变成了包含m棵树的森林。当然，根据定义，一棵树也可以称为森林。

#### 二叉树

二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。

二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。

二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。

当集合为空时，称该二叉树为空二叉树。

二叉树特点是每个节点最多只能有两棵子树，且有左右之分。

- 若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有$2^{i-1}$个结点。
- 若规定根节点的层数为1，则深度为h的二叉树的最大结点数是$2^h-1$。
- 若规定根节点的层数为1，具有n个结点的满二叉树的深度，$h=\log_{2}{n+1}$（是log以2为底，n+1为真数）。

##### 满二叉树

国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是$2^k-1$，则它就是满二叉树。

国外(国际)定义:如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。国内外定义不同，有歧义。一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树。

从图形形态上看，满二叉树外观上是一个三角形。从数学上看，满二叉树的各个层的结点数形成一个首项为1，公比为2的等比数列。

##### 完全二叉树
深度为k，有n个节点的二叉树当且仅当其每一个节点都与深度为k的满二叉树中编号从1到n的节点一一对应时，称为完全二叉树。满二叉树是完全二叉树的特殊形态。

##### 二叉排序树

1. 可以为空树；
2. 如果根结点有左子树，其左子树上的任何结点都要比根结点的值小；
3. 如果根结点有右子树，其右子树上的任何结点都要比根结点的值大；
4. 根结点的左右子树也要满足以上三个条件。

此二叉树为一棵二叉排序树（BST）。二叉排序树又称为二叉搜索树，或二叉查找树。

二叉排序树每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；

CURD 时间复杂度$O(\log{n})$，最差O(n)。

对一个二叉树做升序插入，新插入的数据总是比已存在的结点数据都要大，那么每次都会往结点的右边插入，最终导致这棵树严重偏科！最坏的情况，也就是一棵树退化为一个线性链表了，这样查找效率自然就低了，完全没有发挥树的优势了呢！

为了较大发挥二叉树的查找效率，让二叉树不再偏科，保持各科平衡，所以有了平衡二叉树！

##### 平衡二叉树
1. 左右两个子树的高度差的绝对值不超过1。
2. 左右两个子树都是一棵平衡二叉树。

此二叉树为一棵平衡二叉树 (AVL Trees)。

CURD 时间复杂度$O(\log{n})$。
平衡二叉树的常用实现方法：AA树、AVL树、红黑树、树堆Treap、伸展树等。

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的reblance，导致效率下降。

`平衡因子=左子树高度-右子树高度`

当平衡因子为1，-1，0时，当前的树处于平衡状态，当平衡因子为2，-2时，当前树处于不平衡状态，需要进行自平衡。

插入节点时，找插入新结点后失去平衡的最小子树，该子树要求：

1. 距离插入结点最近。
2. 平衡因子绝对值为1的结点作为根。

删除结点时：

1. 删除结点是当前根节点。找高度较大的子树。
1. 删除结点是当前根左节点。找高度较大的子树。

自平衡调整：

1. LL（左左）：右单旋转（顺时针旋转），右子结点给父结点的左结点，将原根结点作为rootLeft的右结点，让rootLeft成为新的根结点
1. LR（左右）：先左旋（成LL）再右旋
1. RR（右右）：左单旋转（逆时针旋转），左子结点给父结点的右结点，将原根结点作为rootRight的左结点，让rootRight成为新的根结点
1. RL（右左）：先右旋（成RR）再左旋

LL：3、2、1 => 2、1、3
LR：3、1、2 => 3、2、1 => 2、1、3
RR：1、2、3 => 2、1、3
RL：1、3、2 => 1、2、3 => 2、1、3


##### 红黑树

红黑树（Red Black Tree，RB-Tree） 是一种自平衡二叉查找树。典型的用途是实现关联数组。

红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。

红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在$O(\log{n})$时间内做查找，插入和删除，这里的n 是树中元素的数目。

1. 节点是红色或黑色。
2. 根节点是黑色的。
3. 空节点是黑色的（红黑树中，根节点的parent以及所有叶节点lchild、rchild都不指向NULL，而是指向一个定义好的空节点）。
4. 红色节点的父、左子、右子节点都是黑色。
5. 在任何一棵子树中，每一条从根节点向下走到空节点的路径上包含的黑色节点数量都相同。

如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次(因为不需要严格的平衡，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长)旋转以及修改节点的颜色，只需要O(1)的复杂度。

其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

##### B-Tree

多路平衡搜索树

二叉查找树的结构不适合数据库，因为它的查找效率与层数相关。越处在下层的数据，就需要越多次比较。对于数据库来说，每进入一层，就要从硬盘读取一次数据，这非常致命，因为硬盘的读取时间远远大于数据处理时间，数据库读取硬盘的次数越少越好。

假设一颗平衡二叉树的高度为h，每一层最多容纳的结点数量为$2^(n-1)$，整棵树最多容纳节点数为$2^h-1$。这样计算，100w数据树的高度大概在20左右，那也就是说从有着100w条数据的平衡二叉树中找一个数据，最坏的情况下需要20次查找。如果是内存操作，效率也是很高的！但是我们数据库中的数据基本都是放在磁盘中的，每读取一个二叉树的结点就是一次磁盘IO，这样我们找一条数据如果要经过20次磁盘的IO？那性能就成了一个很大的问题了！那我们是不是可以把这棵树压缩一下，让每一层能够容纳更多的节点呢？虽然我矮，但是我胖啊...

1. 每个结点最多m个子结点。
2. 除了根结点和叶子结点外，每个结点最少有m/2（向上取整）个子结点。
3. 如果根结点不是叶子结点，那根结点至少包含两个子结点。
4. 所有的叶子结点都位于同一层。
5. 每个结点都包含k个元素（关键字），这里$m/2≤k<m$，这里m/2向下取整。
6. 每个节点中的元素（关键字）从小到大排列。
7. 每个元素（关键字）字左结点的值，都小于或等于该元素（关键字）。右结点的值都大于或等于该元素（关键字）。

##### B+Tree

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构。

1. 所有的非叶子节点只存储关键字信息。
2. 所有卫星数据（具体数据）都存在叶子结点中。
3. 所有的叶子结点中包含了全部元素的信息。
4. 所有叶子节点之间都有一个链指针。




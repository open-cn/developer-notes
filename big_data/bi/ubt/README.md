## 用户行为追踪

### 埋点
埋点的很大一部分用途是为了做报表呈现当前产品的大盘状态，比如整体的新增、活跃、留存、回流，以及各个功能模块的使用情况。

绝大部分的公司都没有埋点管理系统，大多都是以excel的方式进行管理，虽然excel管理也不是不可行，埋点的形式天然就具有表格的样式，问题在于埋点人员对埋点管理的认识参差不齐，所以埋点文档百花齐放，纷繁复杂，混乱不堪是常见的。

#### 产品梳理

##### 功能梳理
##### 交互梳理

#### 埋点流程

要做好一件事，必须知道其具体流程，埋点虽然听起来简单，其实也是一个系统性的工程，需要各方共同参与。以当前主流的前端代码埋点为例，埋点牵涉到产品经理、数据产品经理、数据开发、业务开发、数据测试五个角色，在一些企业的设置中可能并没有数据产品的角色，其角色就会有数据开发来兼任，此外很多的数据测试也是由业务测试来兼职的。但不管角色的多少还是兼职，埋点所遵循的流程改动并不大。

#### 角色职责
- 产品经理：输出策划文档、统计需求(一般是以报表需求的形式呈现，也是数据产品埋点转换的重要参考)
- 数据产品经理：负责进行埋点转化，对埋点的完整性负责，其一般有两个转化参考点,一是策划文档，根据相应的改动增加相应的曝光、点击等埋点事件，另一个参考就是报表需求文档，通过完善已有的埋点(常见的有增加参数、增加参数值等)或者增加新的埋点来支撑报表需求。
- 数据开发：根据产品输出的埋点转化文档，进行埋点设计，具体体现为埋点参数名、参数值、上报时机等，对埋点的准确性负责。业务开发：根据数据开发输出的埋点设计文档，根据响应的触发时机，将事件相关的设计的附属信息按指定的格式进行上报，对埋点植入的正确性负责、对采集数据的完整性负责（漏掉一些上报时机是很常见的事）。数据测试：根据业务开发的上报，通过测试用例抓包的方式验证数据的上报是否和埋点设计的一致，验证一致后发起埋点验收报告。

##### 注意
- 产品提出统计需求的时候，需要用到哪些数据最好能先和开发沟通一下，是否能获取到，可以极大的减少在埋点需求和设计评审时讨论开发能否实现的耗时。
- 数据测试发起埋点验收报告的时候，上报数据要经过筛选，只核验本次埋点设计改动的地方，并见埋点设计的改动和上班数据的对应关系标注出来，可以极大的加快数据验收的进度。（数据验收目前还有很多的挑战，比如参数值的层级组合等，只能做简单的自动化）

#### 埋点设计思维

- 漏斗思维
- 层次思维
- 扩展思维
- 分类思维

##### 漏斗思维
漏斗思维即分阶段思维，是从流水线的角度考虑问题，追踪整个链条，具体有以下两种形式。

1. 同一事件的不同阶段：在埋点设计中时常会遇到一些持续性的事件，不是在瞬间完成的，比如播放、下载等，都存在这一定的持续阶段，对于这样的非孤立事件，要设计一个链条进行追踪，在埋点设计中常用会话的方式表示，比如可以采用开始时间戳的方式作为会话id,每次事件开始都会生成不同的事件id。此外在设计埋点的事件名的时候也应该显著的进行区分，比如用同一个事件，然后在该事件的属性参数中选择一个类似step的参数来代表该事件的不同阶段，若每次事件的消费对象具有唯一的标示符如indentid，这样就可以使用 imei+eventid+step+indentid 这四个值串联了该次事件的整个过程。也可以用不同的事件名进行串联事件(或者过程)的不同阶段。

2. 同一事件的不同平台：不同平台的串联简单来说是入口要做统计，出口也要统计，做好衔接，形成一个完整的漏斗。以分享为例，客户端的分享（点击开始分享、分享结果返回）要做埋点，分享出去的页面的展现和点击也要设计埋点，在设计埋点参数的时候要注意加入加密处理过的用户标示、分享来源标示等，代表一次完整的分享会话，做好跨平台之间的信息透传，避免链条中断或者模糊。这里需要强调的是不同平台的串联容易泄露用户数据，要注意加密处理进行隐私保护。

##### 层次思维
层次思维的是指在进行埋点设计的时候，要有将页面逻辑、事件过程、扩展参数等设计的有层次感。不仅可以方便对埋点进行查找，而且可以在更高维度上概括。具体体现在以下方面：

1. 交互层次<br>
交互层次主要处理母页面和子页面的展现和点击事件，对于某些app为了界面上的清洁，对一些行为操作进行了折叠，常见的场景如点击更多，出现分享、保存等操作按钮，长按评论，出现删除、复制、举报等操作，这些在弹出界面上的简答操作可以上卷到母页面上进行处理，比如原来的母页面上评论有点赞和回复两个点击位置，则子页面上点击上卷之后，就有点赞、回复、长按_复制、长按_删除四个点击位置，其中以长按代表子页面上的点击，这样上报更加清晰明了。但需要注意的是对于一些复杂的功能多样的子页面，要将这些页面当做普通的页面进行处理，并在页面相关的事件上进行普通页面和弹出页面的属性区分。

2. 属性层次组合<br>
属性层次常见于具有复杂参数上报的事件中，属性的参数值之间存在层次的组合关系，比如A参数取值为A1的情况下，B参数有B1,B2取值的可能，而当A参数为A2值的情况下，B参数有B3、B4取值的可能，像这种同一事件属性层次的组合关系又适合拆分成多个事件的情况下，建议使用参数组合表进行设计的展示，可以极大的方便开发处理各种逻辑和测试案例的完备性。

3. 属性层次包含<br>
属性层次包含是指在参数取值具有很明显的分类情况下，设计更高的层次来给每个类进行命名。比如参数A具有A1、A2、A3、A4...A9一系列值，A1、A2属于类C1，A3属于类C2，A4...A9属于类C3，若这一些列值存在明显的可区分特征，则在统计该类值过滤下相关事件行为即可，若不存在，则需要很繁琐的穷举，不仅代码臭长，而且当有新的该类值出现的时候，要不断的修改统计代码。此时若在参数设计上增加一个参数来进行C1、C2、C3的划分，则可以轻松的解决刚才的问题。

##### 扩展思维
扩展思维是抽象思维的一种体现，越抽象的事物越容易扩展，但并不是说越抽象越好，把握号抽象的程度，可以有效的提高扩展性。

1. 事件扩展<br>
在设计事件的时候要有对业务扩展的预见性，比如一个app最初只具有发布自拍视频的功能，那么在设计视频发布相关的事件的时候是否应该采用shortvideo_publish_xx呢？如果采用这种事件id的数据方式，若以后新增了其它类型内容的发布，其基本流程和视频的发布基本类似，此时是将视频发布的相关事件流程重新复制一份，还是新增content_publish_xx事件，使用type参数来代表发布不同的内容类型（排除视频外的,就版本埋点事件要兼容），不论采用哪种设计，都会让埋点变得混乱，而如果最终设计的时候就采用content_publish_xx的方式进行设计，则就整洁很多，很容易扩展。

2. 属性扩展<br>
属性扩展在属性值的上报格式上体现十分明显，此外 扩展格式设计的时候要不影响已有数据的原始处理逻辑，表现在埋点上尽可能的采用增加属性和属性值的方式进行 埋点，避免一大堆不可复用的垃圾事件，增加管理的难度。具体的措施如下:采用字典的方式进行埋点,尽量不要采用分隔符分割的列表方式，例如:vid1_vid2_vid3 对可能出现的逻辑进行顶层设计区分,在每层上同样采用字典的方式 对多个事件引用的同一属性的枚举值，建议用表分割出来，不要在每个事件上一个个地修改 卡片类等点击内容可能多个的情况，在设计之初就应该有clickid属性用以区分点击的具体位置 针对点击事件的针对性，比如针对某条评论的点击恢复，点赞等，在点击事件中要设计针对属性。

##### 分类思维
按位置、按模块、按页面、按功能等多角度进行分类，有时将行为从页面中独立出来形成单独的一类，比如如果app中在多个地方都存在分享、评论和点赞等功能，而这些行为的统计又是经常使用到的指标，更甚至若在底层实现上这些模块都继承自同一个模块，这就天然具有了在埋点设计的时候按行为分类，而不是在每个页面的位置上都单独设计埋点事件。试想一下如果各个页面维护各自的分享模块，如果分享渠道增加一个，那么是不是要更新所有页面分享的埋点设计，追加响应的参数值(当然如果所有页面虽然使用了不同的事件，但是维护的是同一份信息表就相对好些)。另一方面，如果指标体系十分关注app在不同位置、来源上提供的内容消费差异，则要求我们在进行行为分类设计埋点的时候加入其来源相关的信息，并对来源按来源app(跨app的导流)、来源页面（app内部）、来源控件（app内部的某一位置）。

#### 埋点设计典型场景

- 刷新流
- 列表式
- 点击相关
- 联动演化

##### 刷新流
刷新流又称服务流，是在新闻资讯类APP中常见的交互形式，随着用户不断的滑动，内容不听的更新，根据刷新的方式有分为全部刷新和增量刷新，而增量刷新有时候在页面的顶部，有时在页面的底部。对于刷新流埋点我们要终端关注上报的数据信息和上报时机。

上报数据：

- refresh_num：第几次刷新（0代表首次进入，没有刷新）
- refresh_id：刷新id(包括下拉刷新和加载更多)
- refresh_type:是否系统自动刷新，sys-系统自动刷新，manual-用户触发刷新
- position：元素刷新部分的位置(在每次刷新中的位置)
- rn:元素位于列表位置(在所有刷新中的位置)
- sessionid:用户一次连续使用id(用户首次进入首页生成，顶部刷新时更新

上报时机：

- 一般先加入缓存，缓存满多少条上报，或者结合一些其它的上报时机。上报完成之后清空缓存，新曝光的加入缓存，等待新的上报时机被触发。
- 用户来回滑动也正常加入到缓存中，回滑加入缓存不去重

##### 列表式
曝光上报的一个基本原则是用户可见(离开之后再次可见算二次曝光)

上报格式：
列表式的曝光常采用多条一起上报的方式，每个条目有共性和个性属性两部分，个性属性的上报，有两种常用的方式：json嵌套、固定分割。

上报时机有以下几种处理方式：

简单式：离开页面的时候上报所有已曝光过的内容，但可能出现的问题对于刷新流的内容形式，一次上报的内容可能超出了限制，造成数据丢失。

混合式：混合式的上报在简单式的离开上报基础上增加了缓存条数的触发上报条件，缓存达到了指定数目之后，则将缓存过的数据进行上报，同时清空缓存等待新的曝光条目加入。

综合起来，在处理曝光事件的上报时机的时候要充分的考虑以下场景：

- 缓存数据满上下滑动等的重复曝光是否加入缓存快速滑动是否加入缓存
- 离开tab切换（内容是否刷新）实体键返回/软键返回息屏（息屏之后解锁）折叠展开隐藏的内容浮层/弹窗等遮挡进下级页面

*注意事项*<br>
在处理曝光内容的时候，有以下几点需要提前考虑：

- 重复曝光是否计算在内，即集合和列表的区别。
- 悬浮的授权弹窗下的页面曝光，需要授权弹窗消失后才能上报

##### 点击相关
点击延后
点击埋点的上报时机一般不存在疑问，即点击发生时候或者点击结果返回时上上报，但在处理一些特殊场景的时候合理的制定上报时机，会给后续数据处理带来极大便捷性。典型的使用场景是单页面批量操作，具体如下：

单选或多选、然后一起操作(操作结果:关注/删除/移动)
单选，每个选择有单独的操作结果(页面不发生跳转)，整个页面是每个操作的结果组合
以上两种场景，建议离开当前页的时候上报该页面操作的结果，可 以选择上报所有操作之后的最终态，也可以记录修改态(增什么减什么保留了什么，开什么关什么不变什么)

点击附着
具有附加信息的点击事件上报，建议单独拿出来，这是因为每个点击对象都导致不一样的结果，而这些 结果有时候又没有共性(有共性的情况下可抽象成一个点击事件)。具体的点击附着场景如下：

点击评论这个事件，就附着了评论的id、评论作者的id等信息，如果归结到统一的点击事件，就需要加额外的信 息。而这些信息是其它的点击事件所不具备的，例如点击返回(就没有附着的对象id)
点击具有跳转能力的对象，就要记录点击的位置，跳转前的属性(比如当前url)和跳转后的属性(比如跳转url) - 点击具有红点提示和消息条数提示的控件，则需要上报控件的状态(是否有红点或消息条目的多少)
点击具有附带结果，比如关注等，附带结果是否要上报(牵涉到上报时机)
点击信息表
对于某些特殊的入口型应用，或者具有丰富内容形态的产品，有很多的交互设计，点击不同的地方，跳转不同的位置，甚至相同的位置，随着后台的配置不同而跳转不同的地方。这种具有丰富的复杂的跳转关系情况下，如果继续采用属性和属性值堆叠的方式，不仅不能很好的体现属性值之间的组合情况，以便测试和其它人员进行针对性的测试，也不利于使用人员快捷的进行点击信息的统计，此时建议采用信息表的方式来设计，其形式如下：

| 点击区分      | 点击位置       | 跳转区分          | 跳转地址       |
| ------------- | -------------- | ----------------- | -------------- |
| 按钮/非按钮等 | 具体的点击位置 | 应用自身/第三方等 | 具体的跳转目标 |

*说明*

- 点击区分重点按是否点击率计算的分之来区分
- 跳转区分是否跳转跳转到应用自身还是第三方
- 跳转地址若是应用内部的跳转，直接用对应的页面编码即可应用外部的跳转，若是拉起具体的应用，则给出具体的包名，若是地址形式，则直接给出地址

##### 联动演化
联动：联动是指显性的某些操作引起其它地方状态改变的一些关联变动（而这些变动同样可有其它的显性操作引起），这个时候要注意被联动的状态改变的上报（同时也要注意区分出状态改变的原因），这些联动可以是层级的关系（上层关闭，下层自动关闭），也可以是平级的关系。比如一些内容服务类的app，提供内容类型的关注，并同时可定制内容子类型，当子类型全部删除后，则父类型自动取消关注。这种情形下，父类型的取消关注就会有两种方式，一种是直接取消父类型，一种是通过对子类型的操作联动父类型的改变。另外一些隐性的联动也可以通过事件映射的方式下沉到埋点层解决，如果没有这个将同类型操作结果的事件在底层映射成一个，很容易造成埋点遗漏，如果后面又利用此事件建立了开关累积表，则统计的准确性大大降低，而且修复起来也很复杂。

演化：演化是指在一个行为发生的过程中该行为附带的属性会发生变化，比如在一次播放过程中清晰度的切换、暂停和继续、播放器界面的小屏和大屏切换等，或者随着时间推移弹窗内容的改变等，这些存在演化的行为，一般的建议是用一个标示符串联起来，比如播放用的sessionid串联一次完整的播放，下单过程的产生订单id（注意区分成功之后的订单id）,在某些场景要求不细的情况，可合并到事件的某个阶段一起来上报，不用拆分阶段来追踪整个链条。

#### 埋点设计准则
- 同质一致
- 同质继承
- 通用复用
- 粒度平衡

##### 同质一致
1. 相同指标度量的上报时机和格式一致，比如:

- 实体返回键和app返回键及空白位置的点击clickid统一处理成return
- 页面停留时长信息的上报，其上报时机为离开页面的时候，时长单位ms
- 多同质元素的曝光，用统一的上报格式

2. 同质参数的名称和类型应该保持一致

同质参数的设计一致主要体现在普通参数、维度参数、行为标识上，虽然这些要求是数仓规范上介绍的，但如果能事先治理，在数据采集的时候就规范化，其能减轻的工作量是巨大的。以下是一些通用的词根：

- 普通字段

| 名称 | 意义    | 备注                      |
| ---- | ------- | ------------------------- |
| 渠道 | channe  | 一般是渠道编号            |
| 版本 | version | 若同时有多个版本，加前缀  |
| 包名 | package | 一般在上报层处理为小写    |
| 来源 | from    |                           |
| 目的 | to      | qq/wechat/weibo/friends等 |

- 行为字段规范

| 行为 | 命名建议 | 备注 |
| ---- | -------- | ---- |
| 点击 | click    |      |
| 曝光 | show     |      |
| 分享 | share    |      |
| 评论 | comment  |      |
| 点赞 | like     |      |
| 举报 | report   |      |
| 安装 | install  |      |
| 下载 | download |      |
| 升级 | upgrade  |      |
| 退出 | exit     |      |

3. 同页面同模块的事件名基本一致

同一个页面的点击事件，应该从事件名上可以直接进行区分，如下：

    1. 进入页面即上报该页面的pv，作为分母(下滑等操作曝光的页面上部分的内容再单独上报各自的show事件)
    2. 页面各个部分的点击遵循:页面名_模块部分名_click/show

##### 同质继承
1. 跳转继承

从A页面跳转到B页面，只在B页面的展现事件上报了from，而在B页面的后续重点操作都没有继承最初进入该页的from属性，或者在B页面的下一级需要重点关注来源的页面也漏报了from属性，都是继承中断的情况。

2. 初始继承

初始继承是指在用户当天（或者更长日期）首次发生某种行为的时候，该行为即成为用户的一种标签，在后续的其它事件的上报上都上报此标签。比如记录首次启动的方式，桌面图标的启动的，则标注为图标启动用户。虽然后台的数据处理可以计算出用户的这些首次行为标签，但是多个行为的时候可能会存在计算量大的情况。

##### 通用复用
该准则的要求是尽量少的创建新的事件，而是想法复用原来的事件，这不仅是减少事件数量，方便后续的埋点管理，同时在思考能否复用的过程中，也是对自己埋点设计的能力的一次检验，检验埋点设计的扩展性如何。

##### 粒度平衡
粒度平衡指埋点粒度在最小化的原子粒度和抽象粒度概括之间要平衡，常见的有以下几个方面：

1. 时间粒度
时间粒度在盒子不变，其交互也不变，而盒子里的内容通过左右滑动或者点击跳转而改变，简言之就是复用同一套模板的交互情况下要特别注意。此处以某详情页的停留时长粒度来举例：事件名：离开详情页事件id： x_detail_exit 上报时机：

- 点击返回、切后台等常规形式的退出
- 点击页面交互元素跳转非同类模板页
- 点击相关推荐等进入同类模板页

参数： stay_duration:停留时长，单位ms 在设计埋点的时候，该事件的停留时长参数就一定要精确到原子粒度，即单个内容的停留时长，而不是该类页面的停留时长。基于单个时长可以统计同类时长，若埋点粒度太粗，就没法分解，这样在计算类似TopN条目的情况，埋点数据就无法支撑了。

2. 事件粒度
虽然我们在设计埋点的时候要求采集的信息要完善，不能漏采，但并不是意味事件的上报并不是越多越好，要全但是不要滥，至于上报哪些事件，则要从整个产品交互逻辑和漏斗分析的重点对象出发，在满足版本迭代功能需求统计基础上，不断补齐漏斗环节。

事件的串联此外事件粒度也体现在埋点设计上，可以将一个串的事件用一个时间id，而在params里使用attribute1这个参数来代表不同的阶段，进行了埋点展平，同时这样的拆分设计也可以避免在不同的阶段下，附带的参数不一致，而需要不断的说明层级的关系。

时间粒度的上报数据量度量此外在处理类似心跳事件这样可能造成大量数据上报的情况，要有事前的预估，如果可能超出数据的接收能力，则在客户端进行选择性的上报，但要注意上报样本的均匀合理，能够反映总体的特征。

#### 埋点管理

埋点管理归结到底是元数据的管理，而且还是最底层的元数据管理。

从埋点记录的格式角度看，埋点管理是记录事件、事件参数、时间参数的取值随着版本迭代的增删改情况。

从埋点设计的角度看，埋点管理是记录元素（页面、区域、控件）、事件（行为）、上报（时机、网络等）这三个埋点对象随版本的变化情况。

- 管理目的
- 管理准则
- 管理方式
- 埋点验收

##### 管理目的
埋点管理主要有三大目的，即方便查询、方便协同、方便验证。

1. 方便查询

因为埋点是最底层的元数据，在查询报表系统上没有展示的数据时候，产品、运营等可以将需求拆解为统计什么页面上的什么行为，根据页面和行为的简单拆解，通过埋点系统找到对应的埋点设计，然后根据埋点设计从原始的上报数据中查询即可。

2. 方便协同

在埋点设计的过程中，需要产品、数据产品、数据开发和数据测试一起协同工作，而协同的根本就是埋点设计文档，而埋点设计文档是随着终端版本的更新而不断更新的，如何将这些更新准确地传达给各方，让协同高效，这是埋点管理的重点职责。

3. 方便验证

在选择何种埋点管理方式的时候，一个重要的考虑点是能否将埋点设计的变更导出成可自动化测试的规则，从而可以在测试数据上快速的验证数据是否有上报、格式是否正确、各种情况是否穷尽等。

##### 管理准则
埋点管理需要遵循以下准则：历史兼容、追踪回溯、备注完善

1. 历史兼容
历史兼容是指在埋点设计的时候，有以下三个不可改变:

- 不能改变已有事件标示（事件id等）代表的事件含义
- 不能改变属性标示代表的含义
- 不能改变参数值代表的含义

基于以上三个不可改变，埋点设计只能在原有事件的基础上新增属性、新增参数、新增参数值，也可以在适当的时候废弃某些事件、参数、参数值。

虽然可以随着版本的迭代也容许事件、参数、参数值的含义进行改变，但是十分不可取的，不仅要在改变的过程中详细的记录，而且过度期间数据开发要很好的兼容迁移前和迁移后，待基本完成迁移后，还要精简程序。这无疑带来了很大的工作量。

也正是由于历史兼容的准则，受三个不可变的约束较强，在埋点设计之初就要进行合理的规划和布局，避免后期不得已进行埋点重新设计时带来的混乱。

2. 追踪回溯
追踪回溯功能是埋点出现问题的时候排查的重要利器，要求埋点设计文档可以回退到任何版本的埋点快照（事件、属性和属性值级别），同时可以追踪的对应的操作人（埋点设计者、埋点开发者、埋点测试者等）。

3. 备注完善
备注完善要求详细的标注出事件的上报时机（策略）、参数取值的具体含义，参数值计算方式和单位（尤其是时长类的参数值）、埋点针对的具体点页面位置。

##### 管理方式
不管采用哪种管理方式，都应该记录该埋点涉及的相关人员：

- 埋点类型：<br>
    算法/业务（产品、运营）/监测/数据
- 需求人员
- 开发人员
- 测试人员
- 转化人员：<br>
    数据产品经理（单一，一般可不写）
- 设计人员：
    大数据开发（单一，一般可不写）

不管采用哪种管理方式，都要求输出埋点的改动信息如下：

- 版本改动：<br>
    新增xx事件，事件参数有a,b,cxx事件新增a参数xx事件的a参数新增xx值
- 版本快照：<br>
    该版本生效中的所有事件和参数
- 版本对比：<br>
    xxa版本和xxb版本对比新增了什么，删除了什么，改动了什么。

同时在用户体验上，当鼠标悬浮在某个事件或参数上面的时候（或者点击旁边的问号），可以给出该事件或者参数的历史变更记录。

##### 埋点验收

埋点验收是埋点设计的最后一环，是把控埋点质量的关键环节。

1. 双重验收
一是客户端通过抓包的方式确认数据的确有上报，二是通过数据仓库提取的方式确认数据落地的形式是否和埋点设计一致的

2. 验收预警
一旦上报了不符合埋点设计的值自动预警，比如埋点设计中该参数只有a,b,c三个枚举值，结果却上报了d这个值，这个功能可以反过来保证埋点设计和埋点上报是严格一致的。

另外埋点的上报频次和每次上报埋点数据量的大小也要在预估的范围内，尤其是像加入心跳埋点这样的事件，不然很容易就爆库。

埋点验收问题可以引出数据的自动化测试课题，见数据治理部分。

#### 埋点技术

手动埋点，也叫代码埋点，本质是在客户端或者服务端一些特定的位置用代码拿到一些基本信息，然后返回给服务端。这种埋点方式虽然能精准的监控到用户的行为，和网页性能等数据，但是非常繁琐，需要大量的工作量，当然这部分工作也有人帮我们做了，比如像友盟、百度统计等给我们其实提供了服务。我们可以按照他们的流程使用手动埋点。

可视化埋点，也叫无痕埋点，解放了前端手动操的工作量，其实本质就是用系统去插入本来需要手动插入的埋点，这种埋点方式由于自带技术壁垒，所以开发人员基本基本不用考虑，花钱即可 ，比较靠谱的服务商 国外的Mixpanel，国内较早支持可视化埋点的有TalkingData、诸葛 IO，腾讯 MTA 等

无埋点，也叫全埋点，并不是没有任何埋点，所谓无只是不需要工程师在业务代码里面插入侵入式的代码。只需要简单的加载了一段定义好的SDK代码，技术门槛更低，使用与部署也简单，避免了需求变更，埋点错误导致的重新埋点。这也是大多网站的选择，因为实在太简单了。

#### 前端监控使用GIF进行上报
##### 没有跨域问题
一般而言，打点域名都不是当前域名，所有的GET/POST/HEAD请求都会构成跨域。而跨域请求很容易出现由于配置不当被浏览器拦截并报错。

##### 不会阻塞页面加载，影响用户体验
通常，创建资源节点后只有将对象注入到浏览器 DOM 树后，浏览器才会实际发送资源请求。反复操作 DOM 不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。

但是图片请求例外。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点，这是其他类型的资源请求所做不到的。

##### 在所有图片中GIF体积最小，可以节约网络资源。
上报时选用了1x1的透明GIF，而不是其他的PNG/JEPG/BMP文件。

首先，1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。因为需要透明色，所以可以直接排除JEPG(BMP32格式可以支持透明色)。同样的1x1像素透明图，BMP文件需要74个字节，PNG需要67个字节，而GIF，只需要43个字节。




### 第三方平台

- google analytics
- 友盟优势APP统计，特别是游戏方面的
- GrowingIO亮点在无埋点
- 神策亮点在私有化，技术成熟
- 数数科技（ThinkingData）的用户行为分析方案，私有化、SaaS版本都有，支持全端的埋点采集，数据准确度、分析性能会更好。


如果你的是产品是游戏，选友盟，也可以选 talkingdata

如果你的产品是其他，选Growing/神策

如果是想私有化自己的数据，选神策



##### GA、google analytics

以传统的页面浏览（PV）和会话（Session）为核心，当然，现在也可以手动添加事件（Event）和自定义属性。

如果只是分析基本的 PV、Session，不牵涉自定义事件的话，埋点很简单，不需要太多额外代码。当然，GA 如果要添加事件，也一样是需要写代码的。

GA 的预置分析功能，指标和维度基本是固定的，功能很强大，不仅有 PV、UV，也有漏斗、留存等更高阶的分析功能。不过，即使是固定指标，在维度下钻的时候也是要做抽样的。需要注意的是，GA 的漏斗只能在创建后积累数据，不能向前回溯。而自定义报表（Customer Reports）的指标和维度虽然是不固定的，但是只支持事件分析，不支持漏斗（貌似付费版有自定义漏斗的 beta feature）、留存、回访，并且在免费版上数据量大了自定义报表是要抽样的，付费版可以开启强制不抽样功能。

GA 有免费版，不过功能较弱。付费版很贵，每年 15 万美元起。

GA 的埋点 SDK 没有开源。

GA 有 API 可以拿到报表数据，付费版可以下载细粒度数据。

##### Mixpanel

数据模型是目前最流行的 Event + Profile，并且可以完全地自定义事件，自定义属性。

Mixpanel 目前支持代码埋点和可视化埋点，代码埋点是需要每个地方依次写代码的，可视化埋点的采集能力要弱一些，可以自定义某个控件的操作，但是不能采集自定义属性。不过，依照我们的经验，由于国内的 iOS 和安卓开发都不太遵循官方的开发建议，所以 Mixpanel 的可视化埋点在国内大部分 App 上兼容性极差，可以认为是不可用的。

在事件分析、漏斗、留存、回访等分析功能上，维度和指标都是可以完全自定义的，漏斗也是可以向前回溯的，分析功能非常灵活和强大。

Mixpanel 没有抽样功能。

Mixpanel 有自己的查询语言，用以满足使用者更加复杂的分析需求。

Mixpanel 有免费版，只支持很小很小的数据量。它是按照数据量收费的，很贵。

Mixpanel 的埋点 SDK 是开源的

Mixpanel 有 API，有自己的一套查询语言，可以拿所有的分析结果。也可以按日下载原始数据。

##### 神策分析 SA

数据模型是目前最流行的 Event + Profile，并且可以完全地自定义事件，自定义属性。

可以和 GA 一样，不写额外代码采集默认的页面浏览等操作，也支持代码埋点和可视化埋点。不过，由于其客户大部分是国内公司，所以神策的可视化埋点对于国内各种开发方式下的 App 要比 Mixpanel 好很多，解决了他们的不少坑。

在事件分析、漏斗、留存、回访等分析功能上，维度和指标都是可以完全自定义的，漏斗也是可以向前回溯的，分析功能非常灵活和强大。

神策分析可以选择是抽样还是全量。

神策分析支持 SQL，用以满足使用者更加复杂的分析需求。

从理念上，神策分析是提供一个全家桶式的解决方案，以 PaaS 平台的方式为客户提供一个完整的数据处理平台，帮客户搭建好数据仓库，所有的数据、存储、计算、查询都是向客户开放的。

神策重视数据源，支持私有化部署，注重客户数据隐私安全，帮助企业构建数据基础，积累数据资产。数据采集好之后，再去支撑更复杂的数据分析需求。

神策分析没有免费版，不过提供了一定时间的免费使用。神策分析的 SaaS 版本是按照数据量收费的，私有部署版是按照机器规模收费，不过，相较而言，由于主要面向中国客户，所以收费相对更加低廉一些。

神策的埋点 SDK 是开源的

神策有 API 可以拿到所有的分析结果，可以自己写 SQL，并且私有部署的话，由于是一个 PaaS 平台，在数据处理的各个环节，客户都可以直接获取和使用数据，与自己的系统集成。


##### GrowingIO

 GIO 只支持SaaS 云部署，产品相对轻量，但无埋点方案只能采集有限的前端行为和属性数据，没有深度打通业务数据，无法采集业务端行为，例如在电商、互金等行业中，无法支持与业务交易数据相关的运营分析需求，像退款事件的分析。

GIO 不支持用户行为明细数据的导出<br>
GIO 不支持实时数据的订阅<br>
GIO 不支持任意维度的组合下钻和筛选<br>
GIO 不支持指标预警、指标自定义、指标的四则运算<br>



### 用户的行为构建模型
当根据用户的行为构建模型时，通常会区分显式和隐式数据收集形式。

- 显式数据收集的示例包括：

- 要求用户按滑动比例对项目进行评分。
- 要求用户搜索。
- 要求用户从最喜欢到最不喜欢的项目集合进行排名。
- 向用户展示两个项目并要求他/她选择其中更好的一个。
- 要求用户创建他/她喜欢的项目列表（参见Rocchio 分类或其他类似技术）。

- 隐式数据收集的示例包括：

- 观察用户在在线商店中查看的商品。
- 分析项目/用户查看时间。
- 记录用户在线购买的物品。
- 获取用户在他/她的计算机上收听或观看的项目列表。
- 分析用户的社交网络并发现类似的好恶。



## JAVA

1. Java SE Platform

前身：J2SE（Java 2 Platform, Standard Edition），2005年之后更名为JAVA SE

2. Java ME Platform

前身：J2ME（Java 2 Platform, Micro Edition），2005年之后更名为JAVA ME

3. Java EE Platform

前身：J2EE（Java 2 Platform, Enterprise Edition），2005年之后更名为JAVA EE

### JVM

1. 方法区：class类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等。
1. 堆：初始化的对象，成员变量（那种非 static 的变量），所有的对象实例和数组都要在堆上分配。
  - 堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace）
  - 新生代包含 Eden 区和 Survivor 区，survivor 区里面分为 from 和 to 区
  - 内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区。当新生区满了之后会触发 YGC，先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。
  - 如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。
1. 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8大基础类型加上一个应用类型，所以还是一个指向地址的指针。
1. 本地方法栈：主要为 Native 方法服务。
1. 程序计数器：记录当前线程执行的行号。


3. GC 的两种判定方法
引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收但是 JVM没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A） 的情况。
引用链法： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，如果有一条链能够到达 GCROOT 就说明，不能到达 GC ROOT 就说明可以回收。


有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载
方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
该区域是被线程共享的。
方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。
虚拟机栈:

虚拟机栈也就是我们平常所称的栈内存,它为 java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
虚拟机栈是线程私有的，它的生命周期与线程相同。
局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定
操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。
本地方法栈：

本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。

堆
java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

程序计数器

内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码，指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

7.如和判断一个对象是否存活?(或者 GC 对象的判定方法）
判断一个对象是否存活有两种方法:
1.引用计数法

所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象B 又引用者对象 A，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

2.可达性算法(引用链法)

该算法的思想是：从一个被称为 GC Roots的对象开始向下搜索，如果一个对象到 GCRoots 没有任何引用链相连时，则说明此对象不可用。
在 java 中可以作为 GC Roots 的对象有以下几种:

虚拟机栈中引用的对象
方法区类静态属性引用的对象
方法区常量池引用的对象
本地方法栈 JNI 引用的对象
虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记

如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。

如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承

诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 FQueue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。

8.java 中垃圾收集的方法有哪些?
标记-清除: 这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：
1.效率不高，标记和清除的效率都很低；
2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。

复制算法: 为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。

于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。

每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(java 堆又分为新生代和老年代)

标记-整理：该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理或者 标记-清除。

9.什么是类加载器，类加载器有哪些?
实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

启动类加载器(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。
扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH） 来加载 Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。
用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。
10. 类加载器双亲委派模型机制？
当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

11.什么情况下会发生栈内存溢出？
1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；
2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；
3、调整参数-xss去调整jvm栈的大小

12.怎么打破双亲委派模型？
自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法；

13.强引用、软应用、弱引用、虚引用的区别？
强引用：强引用是我们使用最广泛的引用，如果一个对象具有强引用，那么垃圾回收期绝对不会回收它，当内存空间不足时，垃圾回收器宁愿抛出OutOfMemoryError，也不会回收具有强引用的对象；我们可以通过显示的将强引用对象置为null，让gc认为该对象不存在引用，从而来回收它；

软引用：软应用是用来描述一些有用但不是必须的对象，在java中用SoftReference来表示，当一个对象只有软应用时，只有当内存不足时，才会回收它；
软引用可以和引用队列联合使用，如果软引用所引用的对象被垃圾回收器所回收了，虚拟机会把这个软引用加入到与之对应的引用队列中；

弱引用：弱引用是用来描述一些可有可无的对象，在java中用WeakReference来表示，在垃圾回收时，一旦发现一个对象只具有软引用的时候，无论当前内存空间是否充足，都会回收掉该对象；
弱引用可以和引用队列联合使用，如果弱引用所引用的对象被垃圾回收了，虚拟机会将该对象的引用加入到与之关联的引用队列中；

虚引用：虚引用就是一种可有可无的引用，无法用来表示对象的生命周期，任何时候都可能被回收，虚引用主要使用来跟踪对象被垃圾回收的活动，虚引用和软引用与弱引用的区别在于：虚引用必须和引用队列联合使用；在进行垃圾回收的时候，如果发现一个对象只有虚引用，那么就会将这个对象的引用加入到与之关联的引用队列中，程序可以通过发现一个引用队列中是否已经加入了虚引用，来了解被引用的对象是否需要被进行垃圾回收；
### Java内存模型（JMM）

我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。

Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。

Java内存模型（不仅仅是JVM内存分区）：调用栈和本地变量存放在线程栈上，对象存放在堆上。

- 一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。
- 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。
- 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。
- 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。
- 静态成员变量跟随着类定义一起也存放在堆上。
- 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。

#### 硬件内存架构
现代硬件内存模型与Java内存模型有一些不同，理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。

1. 多CPU：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。
2. CPU寄存器：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。
3. 高速缓存cache：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。
4. 内存：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。
5. 运作原理：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。

一些问题：（多线程环境下尤其）

1. 缓存一致性问题：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等：
2. 指令重排序问题：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化

Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：

- 线程之间的共享变量存储在主内存（Main Memory）中
- 每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。
- 从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
- Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。

##### JMM模型下的线程间通信
线程间通信必须要经过主内存。

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

1. lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
1. unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
1. read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
1. load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
1. use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
1. assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
1. store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
1. write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

##### Java内存模型解决的问题

当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。Java内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争race condition）。

1. 多线程读同步与可见性

> 可见性（共享对象可见性）：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改

线程缓存导致的可见性问题：

> 如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中，然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。

解决这个内存可见性问题你可以使用：

> 1. Java中的volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。
> 2. Java中的synchronized关键字：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。
> 3. Java中的final关键字：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）

重排序导致的可见性问题：

> Java程序中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。
>
> Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：
>
> 1. volatile关键字本身就包含了禁止指令重排序的语义
> 2. synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入

指令序列的重排序：

> 1) 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
> 2) 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
> 3) 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序：

数据依赖：

编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑）


指令重排序对内存可见性的影响：

当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。这样的结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。

as-if-serial语义：

不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。（编译器、runtime和处理器都必须遵守as-if-serial语义）

happens before：

从JDK 5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性：在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系：

> 1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
> 1. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
> 1. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
> 1. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
> 1. 一个happens-before规则对应于一个或多个编译器和处理器重排序规则

内存屏障禁止特定类型的处理器重排序：

重排序可能会导致多线程程序出现内存可见性问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。

StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。

2. 多线程写同步与原子性

多线程竞争（Race Conditions）问题：当读，写和检查共享变量时出现race conditions。

如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。

解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。

使用原子性保证多线程写同步问题：

原子性：指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。

实现原子性：

由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，我们大致可以认为基本数据类型变量、引用类型变量、声明为volatile的任何类型变量的访问读写是具备原子性的（long和double的非原子性协定：对于64位的数据，如long和double，Java内存模型规范允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，即如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。但由于目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此在编写代码时一般也不需要将用到的long和double变量专门声明为volatile）。这些类型变量的读、写天然具有原子性，但类似于 “基本变量++” / “volatile++” 这种复合操作并没有原子性。
如果应用场景需要一个更大范围的原子性保证，需要使用同步块技术。Java内存模型提供了lock和unlock操作来满足这种需求。虚拟机提供了字节码指令monitorenter和monitorexist来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步快——synchronized关键字。


##### JMM对特殊Java语义的特殊规则支持

- volatile（保证内存可见性：Lock前缀的指令、内存屏障禁止重排序）
- synchronized（保证内存可见性和操作原子性：互斥锁；锁优化）

### 搭建环境

1. 下载jdk:选择正确的平台，编译器、工具集和一个运行环境
      windows、linux、mac
      java.lang.String
      
      安装目录：
        bin   工具集  javac   java   jar   javadoc
        include   本地开发的头文件   jni.h    native
        jre            一个java运行环境
        lib           库文件   \*.jar

2. 配置环境变量
       java_home:和其他软件约定的一个变量名
           tomcat   jboss  weblogic
           java-home   javahome
           java_home=jdk安装目录
           java_home=C:\jdk1.7.0_45
       path:window搜索可行程序的目录，这个环境已经存在；system32
           path=%path%;%java_home%\bin 
           
goagent
fqrouter
lefei
改错：认真看错误提示信息，如果有多个错误先修改第一个错误
javac:编译
java:把类加载到jvm上运行 
       java 类名
       java HelloWorld
       mono  u3d  C#
       
classpath

java学习顺序：javase->sql->jdbc->
	html,javascript,jquery,ajax,css->servlet->
	jsp->struts2[简化web开发],类似有jsf->hibernate->
 	spring-->ejb3.0-->web service

理解，写代码

跨平台：jvm屏蔽了操作系统之间的差异，而java源程序文件编译后产生的是字节码文件(x.class)	，字节码可以直接在jvm上运行
     在一个源程序文件中可以定义多个类，也可以定义多个主函数，
     如果要执行那个类中的主函数，直接在java命令后面跟类名  						
原则：最好在一个源程序文件中定义一个类


javadoc 生成帮助文档
```java
/**
*
*/
javadoc  源程序文件名
api:java内置工具类
String
```      
      
java documentation:training
      
workspace:不要用中文，也不要有空格
project【java project】-->写类-->写代码
      
javac -d e:\ HelloWorld.java
      
包命名原则：把公司的域名倒过来
	http://www.gemptc.com
 	com.gemptc
    
类全名：包名+类名
    
jvm启动时把java.lang包中的所有类加载到内存
        
classpath:jvm搜索字节码文件的路径
	
classpath=f:\
java com.gemptc.HelloWorld
	
标识符：字符、数字、下划线_，美元符$
String package;
int public;
int age;
int i;
String name;
String a;

//为什么需要变量：让程序运行，必须要把软件加载到内存，申请和释放内存
变量的分类：局部变量和成员变量

变量的3要素：
变量划分存储空间的大小（数据类型）、变量名、变量的作用域

变量的作用域(生命周期)：

属性的作用域从定义位置开始，一直到这个类结束;
局部变量作用域从定义位置开始，到这个方法结束

```java
   public void m(){
   		//错误
   	    int i = 20;
		{
			int i = 10;
		}
   }
  public void m(){
   		//正确
		{
			int i = 10;
		}
		 int i = 20;
   
  }
```

3.14  double 8b
123   int         4b
true  false
'a'    'b'
"abcdef"
012=10
int a = 10;
switch(a){
}
boolean  flag = true;
1...100
while(flag){
		//循环体
}
看别人程序，一步一步执行
do...while
for
第一步
第二步
....
while(...){
	    if(..){
	       ....
	       continue;//没有必要
	   }else if(...){
	   	....
	   	continue;
	   }else{
	   	....
	   	continue;
	   }
}
break:可以用在循环中，可以用在switch
continue:只能用在循环中
	
数组：一次定义一批变量，并且能有规律的使用这些变量
int age1;
int age2;
......
类：
属性：每个对象，属性的取值是不一样的
	height
	weight
	age
	name
方法：每个对象，方法是只有一份
	speak
	run
	...
小李：对象
	178cm
	80kg
	20
	"xiaoli"

小王：对象
	175cm
	70kg
	21
	"xiao王"
	
	speak
	run
	...
交通工具：
	speed
	volumn
	vendor
	......
	
	
	increaseSpeed
	run
对象1：
     speed    200码
     volumn 7
     vendor  奥迪
对象2：
     speed    100码
     volumn 5
     vendor  一汽
对象3：
     speed    150码
     volumn 5
     vendor  上海大众

面向对象：封装、继承、多态
封装：把数据封装在类中，不允许在类的外部直接使用
   
方法重载：
     方法名相同
   	 参数类型不同、参数个数不同、参数次序不同

不是方法重载：
```java
    m(int a);
    m(int b);
```
是方法重载：
```java
    m(int a,float f);
    m(float f,int a);
    
    m(int a,float f,double d);
    m(float f,int a);
    
    m(String s);
    m(int a);
```
方法重载(overload)：
	在同一个类中，要求：方法名相同，参数不同

方法覆盖(override)：
	必须要有继承，要求：4点要求
		//1、方法名相同
		//2、参数和返回值类型也相同
		//3、方法的权限不能比父类的方法权限更严格
		//4、子类方法抛出的异常不能比父类方法抛出的异常范围大
super:指向父类的对象引用
1、当子类重写了父类的方法，在重写的方法中调用父类方法
2、调用父类的构造方法：必须写在子类的构造方法第一行
    super(...)
3、当子类的属性和父类中的属性相同时，引用父类的属性
	super.name
this:指向本类对象的引用
  this(...)
  this.name
  
多态：
把子类对象当作父类对象来看；如果子类重写了父类中的某个方法，通过父类对象的引用调用这个方法时，实际上调用的是子类中的方法
```java
 	Person p = new Student(.....);
 	String s  = p.getInfo();
```

1、要有继承
2、有方法重写：4点要求
3、要把子类对象赋值给父类的引用

最大程度解决了软件可扩展问题

初始化顺序：
	Person:private int initAge() 
	public Person()
	Student:private String initName()
	public Student()
	
静态的方法可以重写，但是不产生多态

面向接口编程

```java
public interface Movable{
	public void run();
}
```

接口与接口之间继承关系:可以多继承
`public interface IA extends IB`

类与类之间的关系继承：单继承
类和接口之间是实现关系
```java
  public class CA extends CB implements IA,IB{
  }
```  

String:对象池；不可变对象；最终类

字符串编码转换
```java  
  iso8859-1 --->utf-8
  String s = "个会尽快yiol";//   iso8859-1
  //获得s表示的字节数组
  byte [] data = s.getBytes("iso8859-1")
  //重现编码
  String str = new String(data,"utf-8");//utf-8编码
```

String:
 char charAt(int index) 
          返回指定索引处的 char 值。 
 int compareTo(String anotherString) 
          按字典顺序比较两个字符串。 
 int compareToIgnoreCase(String str) 
          按字典顺序比较两个字符串，不考虑大小写。 
 String concat(String str) 
          将指定字符串连接到此字符串的结尾。 
 boolean contains(CharSequence s) 
          当且仅当此字符串包含指定的 char 值序列时，返回 true。 
 boolean endsWith(String suffix) 
          测试此字符串是否以指定的后缀结束。 
 boolean equals(Object anObject) 
          将此字符串与指定的对象比较。 
 boolean equalsIgnoreCase(String anotherString) 
          将此 String 与另一个 String 比较，不考虑大小写。 
 byte[] getBytes(Charset charset) 
          使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 
 byte[] getBytes(String charsetName) 
          使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 
 int hashCode() 
          返回此字符串的哈希码。 
 int indexOf(int ch) 
          返回指定字符在此字符串中第一次出现处的索引。 
 int indexOf(int ch, int fromIndex) 
          返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 
 int indexOf(String str) 
          返回指定子字符串在此字符串中第一次出现处的索引。 
 int indexOf(String str, int fromIndex) 
          返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 
 int lastIndexOf(int ch) 
          返回指定字符在此字符串中最后一次出现处的索引。 
 int lastIndexOf(int ch, int fromIndex) 
          返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 
 int lastIndexOf(String str) 
          返回指定子字符串在此字符串中最右边出现处的索引。 
 int lastIndexOf(String str, int fromIndex) 
          返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 
 int length() 
          返回此字符串的长度。 
 boolean matches(String regex) 
          告知此字符串是否匹配给定的正则表达式。 
 String replace(char oldChar, char newChar) 
          返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 
 String replace(CharSequence target, CharSequence replacement) 
          使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 
 String replaceAll(String regex, String replacement) 
          使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 
 String[] split(String regex) 
          根据给定正则表达式的匹配拆分此字符串。 
 String[] split(String regex, int limit) 
          根据匹配给定的正则表达式来拆分此字符串。 
 boolean startsWith(String prefix) 
          测试此字符串是否以指定的前缀开始。 
 boolean startsWith(String prefix, int toffset) 
          测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 
 String substring(int beginIndex) 
          返回一个新的字符串，它是此字符串的一个子字符串。 
 String substring(int beginIndex, int endIndex) 
          返回一个新字符串，它是此字符串的一个子字符串。 
 char[] toCharArray() 
          将此字符串转换为一个新的字符数组。 
 String toLowerCase() 
          使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 
 String toLowerCase(Locale locale) 
          使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 
 String toString() 
          返回此对象本身（它已经是一个字符串！）。 
 String toUpperCase() 
          使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 
 String toUpperCase(Locale locale) 
          使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 
 String trim() 
          返回字符串的副本，忽略前导空白和尾部空白。 
static String valueOf(boolean b) 
          返回 boolean 参数的字符串表示形式。 
static String valueOf(char c) 
          返回 char 参数的字符串表示形式。 
static String valueOf(char[] data) 
          返回 char 数组参数的字符串表示形式。 
static String valueOf(char[] data, int offset, int count) 
          返回 char 数组参数的特定子数组的字符串表示形式。 
static String valueOf(double d) 
          返回 double 参数的字符串表示形式。 
static String valueOf(float f) 
          返回 float 参数的字符串表示形式。 
static String valueOf(int i) 
          返回 int 参数的字符串表示形式。 
static String valueOf(long l) 
          返回 long 参数的字符串表示形式。 
static String valueOf(Object obj) 
          返回 Object 参数的字符串表示形式。 
          
```java
  String s = "    abc  d   ";
  String str = s.trim();//"abc d"
```

写程序：写一部分，测试一部分

```java
//一种写法
try{
	//可能发生异常的代码
}catch(IOException e){
	//异常处理
}catch(SQLException e){
	//异常处理
}

//另外一种写法
try{
	//可能发生异常的代码
}catch(IOException e){
	//异常处理
}catch(SQLException e){
	//异常处理
}finally{
	//最后执行的代码，通常释放资源
}
//第三种写法
try{
	//可能发生异常的代码
}
finally{
	//最后执行的代码，通常释放资源
}
```

事务：一组不可分割的执行单元

```java
    SQLiteDatabase db = helper.getWritableData();
    Transaction tran = db.beginTransaction();
    try{
	    a1 = a1 - 500;
	    //int a = 1 / 0;
	    a2 = a2 + 500;
	    tran.setSuccessfully(true);//设置事务成功
    }finally{
    	 tran.endTransaction();//false:回滚-->a1 = a1 + 500  true:commit
    }
```
Throwable
			Error
			Exception
				RuntimeException:未检验异常
				其他异常:已检验异常
未检验异常:可以不做异常处理
已检验异常：必须要做异常处理，否则编译通不过
throws
throw
	
```java	
	Person p = new Person();
	//集合中存储的是对象的引用：p
```	

List:存储的元素可以是重复，有下标(a[0])
		   list.get(0);
Set:不能存储相同的元素，没有小标
Queue:队列，先进先出:LinkedList  

List:ArrayList,LinkedList(Queue,DeQue)
Set:HashSet
SortedSet: TreeSet

Map:HashMap
SortMap:TreeMap

zhangsan



加入支持jar包源码：
1、右击工程-->properties-->builder path-->libraries-->add external jar-->android sdk/extra/v4/support-v4.jar
2、libraries-->edit source-->右边编辑-->浏览到-->android sdk/extra/v4/src
3、右击工程-->properties-->builder path-->order and export-->support-v4移动顶部


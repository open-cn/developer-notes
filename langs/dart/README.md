## Dart


### 概述
#### 起源

2011 年 10 月，在丹麦召开的 GOTO 大会上，Google 发布了一种新的编程语言 Dart。如同 Kotlin 和 Swift 的出现，分别是为了解决 Java 和 Objective-C 在编写应用程序的一些实际问题一样，Dart 的诞生正是要解决 JavaScript 存在的、在语言本质上无法改进的缺陷。



JavaScript 之父布兰登 · 艾克（Brendan Eich）曾在一次采访中说，JavaScript“几天就设计出来了”。

概括来说，他的设计思路是这样的：

- 借鉴 C 语言的基本语法；
- 借鉴 Java 语言的数据类型和内存管理机制；
- 借鉴 Scheme 语言，将函数提升到“第一等公民”（first class）的地位；
- 借鉴 Self 语言，使用基于原型（prototype）的继承机制。

所以，JavaScript 实际上是两类编程语言风格的混合产物：（简化的）函数式编程风格，与（简化的）面向对象编程风格。

由于设计时间太短，一些细节考虑得不够严谨，导致后来很长一段时间，使用 JavaScript 开发的程序混乱不堪。出于对 JavaScript 的不满，Google 的程序员们决定自己写一个新语言来换掉它，所以 Dart 的最初定位也是一种运行在浏览器中的脚本语言。

为了推广 Dart，Google 甚至将自己的 Chrome 浏览器内置了 Dart VM，可以直接高效地运行 Dart 代码。而对于普通浏览器来说，Google 也提供了一套能够将 Dart 代码编译成 JavaScript 代码的转换工具。这样一来，开发者们就可以毫无顾虑地使用 Dart 去开发了，而不必担心兼容问题。



但，JavaScript 的生命力似乎比预想的更强大。

原本 JavaScript 只能在浏览器中运行，但 Node.js 的出现让它开始有能力运行在服务端，很快手机应用与桌面应用也成为了 JavaScript 的宿主容器，一些明星项目比如 React、React Native、Vue、Electron、NW（node-webkit）等框架如雨后春笋般崛起，迅速扩展了它的边界。

于是，JavaScript 成为了前后端通吃的全栈语言。
如同 Atwood 定律描述的：凡是能用 JavaScrip 写出来的系统，最终都会用 JavaScript 写出来。



JavaScript 因为 Node.js 焕发了第二春，而 Dart 就没有那么好的运气了。由于缺少顶级项目的使用，Dart 始终不温不火。2015 年，在听取了大量开发者的反馈后，Google 决定将内置的 Dart VM 引擎从 Chrome 移除，这对 Dart 的发展来说是重大挫折，替代 JavaScript 就更无从谈起了。

但，Dart 也借此机会开始转型：在 Google 内部孵化了移动开发框架 Flutter，弯道超车进入了移动开发的领域；而在 Google 未来的操作系统 Fuchsia 中，Dart 更是被指定为官方的开发语言。


#### 特性

##### JIT 与 AOT

借助于先进的工具链和编译器，Dart 是少数同时支持 JIT（Just In Time，即时编译）和 AOT（Ahead of Time，运行前编译）的语言之一。



语言在运行之前通常都需要编译，JIT 和 AOT 则是最常见的两种编译模式。

JIT 在运行时即时编译，在开发周期中使用，可以动态下发和执行代码，开发测试效率高，但运行速度和执行性能则会因为运行时即时编译受到影响。

AOT 即提前编译，可以生成被直接执行的二进制代码，运行速度快、执行性能表现好，但每次执行前都需要提前编译，开发测试效率低。

AOT 的典型代表是 C/C++，它们必须在执行前编译成机器码；而 JIT 的代表，则包括了如 JavaScript、Python 等几乎所有的脚本语言。


##### 内存分配与垃圾回收

Dart VM 的内存分配策略比较简单，创建对象时只需要在堆上移动指针，内存增长始终是线性的，省去了查找可用内存的过程。

在 Dart 中，并发是通过 Isolate（隔离区） 实现的。Isolate 是类似于线程但不共享内存，独立运行的 worker。这样的机制，就可以让 Dart 实现无锁的快速分配。

Dart 的垃圾回收，则是采用了多生代算法。新生代在回收内存时采用“半空间”机制，触发垃圾回收时，Dart 会将当前半空间中的“活跃”对象拷贝到备用空间，然后整体释放当前空间的所有内存。回收过程中，Dart 只需要操作少量的“活跃”对象，没有引用的大量“死亡”对象则被忽略，这样的回收机制很适合 Flutter 框架中大量 Widget 销毁重建的场景。


##### 单线程模型

支持并发执行线程的高级语言（比如，C++、Java、Objective-C），大都以抢占式的方式切换线程，即：每个线程都会被分配一个固定的时间片来执行，超过了时间片后线程上下文将被抢占后切换。如果这时正在更新线程间的共享资源，抢占后就可能导致数据不同步的问题。

解决这一问题的典型方法是，使用锁来保护共享资源，但锁本身又可能会带来性能损耗，甚至出现死锁等更严重的问题。

Dart 是单线程模型的优势就体现出来了，因为它天然不存在资源竞争和状态同步的问题。这就意味着，一旦某个函数开始执行，就将执行到这个函数结束，而不会被其他 Dart 代码打断。

所以，Dart 中并没有线程，只有 Isolate（隔离区）。Isolates 之间不会共享内存，就像几个运行在不同进程中的 worker，通过事件循环（Event Looper）在事件队列（Event Queue）上传递消息通信。



##### 无需单独的声明式布局语言
在 Flutter 中，界面布局直接通过 Dart 编码来定义。

Dart 声明式编程布局易于阅读和可视化，使得 Flutter 并不需要类似 JSX 或 XML 的声明式布局语言。所有的布局都使用同一种格式，也使得 Flutter 很容易提供高级工具使布局更简单。

开发过程也不需要可视化界面构建器，因为热重载可以让我们立即在手机上看到运行效果。




### Dart 语法

和绝大多数编译型语言一样，Dart 要求以 main 函数作为执行的入口。

使用 var 定义变量时，表示类型是交由编译器推断决定的。

在默认情况下，未初始化的变量的值都是 null。

Dart 是类型安全的语言，并且所有类型都是对象类型，都继承自顶层类型 Object，因此一切变量的值都是类的实例（即对象），甚至数字、布尔值、函数和 null 也都是继承自 Object 的对象。


Dart 内置了一些基本类型，如 num、bool、String、List 和 Map，在不引入其他库的情况下可以使用它们去声明变量。

Dart 的数值类型 num，只有两种子类：即 64 位 int 和符合 IEEE 754 标准的 64 位 double。前者代表整数类型，而后者则是浮点数的抽象。

除了常见的基本运算符，比如`+、-、*、/`，以及位运算符外，你还能使用继承自 num 的 abs()、round() 等方法，来实现求绝对值、取整的功能。

dart:math 库。这个库提供了诸如三角函数、指数、对数、平方根等高级函数。


在 Dart 里，只有两个对象具有 bool 类型：true 和 false，它们都是编译时常量。不能使用if(nonbooleanValue) 或assert(nonbooleanValue)之类的在 JavaScript 可以正常工作的代码，而应该显式地检查值。


Dart 的 String 由 UTF-16 的字符串组成。和 JavaScript 一样，构造字符串字面量时既能使用单引号也能使用双引号，还能在字符串中嵌入变量或表达式。

对于多行字符串的构建，你可以通过三个单引号或三个双引号的方式声明，这与 Python 是一致的。

数组和字典类型，在 Dart 中的对应实现是 List 和 Map，统称为集合类型。

常量定义需要在定义变量前加上 final 或 const 关键字：

- const，表示变量在编译期间即能确定的值；
- final 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。


#### 类的定义及初始化

Dart 中并没有 public、protected、private 这些关键字，我们只要在声明变量与方法时，在前面加上“`_`”即可作为 private 方法使用。如果不加“`_`”，则默认为 public。不过，“`_`”的限制范围并不是类访问级别的，而是库访问级别。

Dart 还提供了命名构造函数的方式，使得类的实例化过程语义更清晰。此外，与 C++ 类似，Dart 支持初始化列表。在构造函数的函数体真正执行之前，你还有机会给实例变量赋值，甚至重定向至另一个构造函数。


#### “混入”（Mixin）

除了继承和接口实现之外，Dart 还提供了另一种机制来实现类的复用，即“混入”（Mixin）。要使用混入，只需要 with 关键字即可。

当被混入的类有多个同名方法时，调用子类的该方法时，会调用with声明的最后一个拥有该方法的类中的该方法，同时混入中的父类不能继承

混入鼓励代码重用，可以被视为具有实现方法的接口。这样一来，不仅可以解决 Dart 缺少对多重继承的支持问题，还能够避免由于多重继承可能导致的歧义（菱形问题）。

备注：继承歧义，也叫菱形问题，是支持多继承的编程语言中一个相当棘手的问题。当 B 类和 C 类继承自 A 类，而 D 类继承自 B 类和 C 类时会产生歧义。如果 A 中有一个方法在 B 和 C 中已经覆写，而 D 没有覆写它，那么 D 继承的方法的版本是 B 类，还是 C 类的呢？


#### 运算符
Dart 多了几个额外的运算符，用于简化处理变量实例缺失（即 null）的情况。

- ?.运算符：假设 Point 类有 printInfo()方法，p 是 Point 的一个可能为 null 的实例。那么，p 调用成员方法的安全代码，可以简化为 p?.printInfo() ，表示 p 为 null 的时候跳过，避免抛出异常。
- ??= 运算符：如果 a 为 null，则给 a 赋值 value，否则跳过。这种用默认值兜底的赋值语句在 Dart 中我们可以用 a ??= value 表示。
- ??运算符：如果 a 不为 null，返回 a 的值，否则返回 b。在 Java 或者 C++ 中，我们需要通过三元表达式 (a != null)? a : b 来实现这种情况。而在 Dart 中，这类代码可以简化为 a ?? b。
- 级联运算符..：在同一个对象上连续调用多个函数以及访问成员变量。


在 Dart 中，一切都是对象，就连运算符也是对象成员函数的一部分。对于系统的运算符，一般情况下只支持基本数据类型和标准库中提供的类型。而对于用户自定义的类，如果想支持基本操作，比如比较大小、相加相减等，则需要用户自己来定义关于这个运算符的具体实现。

Dart 提供了类似 C++ 的运算符覆写机制，使得我们不仅可以覆写方法，还可以覆写或者自定义运算符。

operator 是 Dart 的关键字，与运算符一起使用，表示一个类成员运算符函数。在理解时，我们应该把 operator 和运算符作为整体，看作是一个成员函数名。







一个函数中可能需要传递多个参数。那么，如何让这类函数的参数声明变得更加优雅、可维护，同时降低调用者的使用成本呢？

C++ 与 Java 的做法是，提供函数的重载，即提供同名但参数不同的函数。但Dart 认为重载会导致混乱，因此从设计之初就不支持重载，而是提供了可选命名参数和可选参数。

具体方式是，在声明函数时：
- 给参数增加{}，以 paramName: value 的方式指定调用参数，也就是可选命名参数；
- 给参数增加 []，则意味着这些参数是可以忽略的，也就是可选参数。











### FAQ

#### 我们在生产环境在用AngularDart，简直就是一个大垃圾。能不能介绍下Flutter for web？

Flutter for web 目前处于内测状态，很多东西都还用不了。加上现在也还很早期，并没有什么最佳实践。












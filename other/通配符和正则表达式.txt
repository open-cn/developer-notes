通配符和正则表达式


通配符是系统level的 而正则表达式需要相关工具的支持: egrep, awk, vi, perl。

在文本过滤工具里，都是用正则表达式，比如像awk，sed等，是针对文件的内容的。
通配符多用在文件名上，比如查找find，ls，cp等等。



【通配符（wildcards）】
通配符叫做文件名通配符更能突出其作用范围，因为通配符主要用于文件名的通配，可以在shell命令中使用。

通配符又叫做 globbing patterns。因为 Unix 早期有一个/etc/glob文件保存通配符模板，后来 Bash 内置了这个功能，但是这个名字被保留了下来。

非预定义的字符类：
*：星号用来匹配任意长度的任意字符。
?：问号用来匹配任意单个字符。
[...]：匹配指定范围内的任意单个字符。
[start-end]：表示一个连续的范围。如[A-Za-z] 匹配大小写字母中的任意单个字符[0-9]，匹配0到9之间的数字。
[^...]  ：匹配指定范围之外的任意单个字符。如[^a-z] = [^[:lower:]]  匹配小写字母a-z之外的任意单个字符。
[!...]：只要不是列在 [! 和 ] 之间的字符，它将与任何字符匹配。
{...}：匹配大括号里面的所有模式，模式之间使用逗号分隔。
{start..end}：会匹配连续范围的字符。


~：当前用户家目录
~username：用户username家目录
~+：当前工作目录
~-：前一个工作目录

注意：
（1）通配符是先解释，再执行。
（2）通配符不匹配，会原样输出。这对{...}不适用。
（3）只适用于单层路径。不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。


预定义的字符类：
[[:digit:]]  相当于[0-9]
[[:lower:]]  相当于[a-z]
[[:upper:]]  相当于[A-Z]
[[:alpha:]]  相当于[A-Za-z]
[[:alnum:]]  相当于[A-Za-z0-9]
[[:blank:]]  水平空白字符
[[:space:]]  水平或垂直空白字符
[[:punct:]]  标点符号
[[:print:]]  可打印字符
[[:cntrl:]]  控制（非打印）字符
[[:graph:]]  图形字符
[[:xdigit:]] 十六进制字符

[^[:upper:]] 排除大写字母
[^[:lower:]] 排除小写字母
[^[:digit:]] 排除数字

注意：上面几个需要使用双重中括号，否则匹配不成功



【正则表达式（REGEXP）】
正则表达式又分为基本正则表达式和扩展正则表达式。正则表达式是用来匹配字符串的。

[基本正则表达式]

元字符：
.点 匹配除“\n”和"\r"之外的任何单个字符。要匹配包括“\n”和"\r"在内的任何字符，请使用像“[\s\S]”的模式。


匹配次数：
* 匹配前面的子表达式任意次。例如，z*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于o{0,}
\? ：匹配其前面的字符1次或0次
\{m,n\} ：匹配前面的字符至少m次，至多n次。




位置锚定 - 行锚定：
^ 匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。
$ 匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。
^$ 空白行。


位置锚定 - 单词锚定：
\< 或者使用\b 锚定词首
\> 或者使用\b 锚定词尾


范围匹配：
[] 匹配指定范围内的任意单个字符。如[a-z][A-Z][0-9]。和通配符中的一样，但此处区分大小写。
[^] 匹配指定范围外的任意单个字符。

字符集合：

分组匹配：

[扩展正则表达式]
元字符：和基本正则表达式一样

匹配次数：
基本正则表达式的\{m,n\}在扩展表达式中不再需要使用反斜线。
+ 加号相当于基本正则表达式中的\{1,\} ：匹配其前面的字符至少一次。
其他的和基本正则表达式中的一样

{m,n} 同基本正则表达式的\{m,n\}一样。
+ 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。
? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。


位置锚定：和基本正则表达式一样
范围匹配：和基本正则表达式一样
字符集合：和基本正则表达式一样
分组匹配：和基本正则表达式一样，但不再需要使用反斜线。
后向引用：和基本正则表达式一样


[匹配模式]
匹配模式默认使用贪婪模式，即尽可能多地匹配所搜索的字符串。
而非贪婪模式则尽可能少地匹配所搜索的字符串。

? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。
例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 ['o', 'o', 'o', 'o']。





